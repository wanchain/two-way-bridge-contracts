#pragma version =0.4.4;

#include "../std/stdlib.fc";
#include "../common/opcode.fc";
#include "../util/slice.fc";
#include "../crypto/secp256k1.fc";
#include "../common/errcode.fc";

(int, int, int, int) ecrecover(int hash, int v, int r, int s) asm "ECRECOVER";

int generate_evm_address(int _x, int _y) inline {
    slice cs = begin_cell()
        .store_uint(_x, 256)
        .store_uint(_y, 256)
        .end_cell().begin_parse();

    int h = slice_hash_keccak256(cs, 1);
    slice cs_h = int_to_slice(h, 256);
    slice cs_last_160 = cs_h.slice_last(160);
    int addr = slice_to_int(cs_last_160, 160);

    return addr;

}

(slice) generate_data_for_e(int evm_address, int gpk_x, int gpk_y, int e, int p, int h) {
    return begin_cell()
        .store_uint(evm_address, 160)       ;; address 20bytes
        .store_uint(p, 8)                   ;; 1byte
        .store_uint(gpk_x, 256)             ;; 32 bytes
        .store_uint(h, 256)                 ;; 32bytes
        .end_cell().begin_parse();
}

(int) verify_sec(int s, int gpk_x, int gpk_y, int e, int p, int h) {

    int sp = secp2561k::n - mulmod(s, gpk_x, secp2561k::n);
    int ep = secp2561k::n - mulmod(e, gpk_x, secp2561k::n);

    int p_ajust = (p > 26) ? p - 27 : p;
    (int prefix, int recover_x, int recover_y, int ret) = ecrecover(sp, p_ajust, gpk_x, ep);

    if (ret == 0) {
        ;; ecrecover error.
        return 0;
    }
    int address_int = generate_evm_address(recover_x, recover_y);

    slice s_e = generate_data_for_e(address_int, gpk_x, gpk_y, e, p, h);
    int e1 = slice_hash_keccak256(s_e, 1);
    return e1 == e;
}

(int) verify_ecdsa(int s, int gpk_x, int gpk_y, int e, int p, int h) {
    (int prefix, int recover_x, int recover_y, int ret) = ecrecover(h, 1, e, s);
    if (ret == 0) {
        ;; ecrecover error.
        return 0;
    }
    if (recover_y != gpk_y) {
        return 0;
    }

    if (recover_x != gpk_x) {
        return 0;
    }
    return -1;
    ;;return (recover_y == gpk_y) && (recover_x == gpk_x); ;;todo && not work??
}