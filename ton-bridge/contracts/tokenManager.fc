#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/common/wkchain.fc";


{-
        uint    id,     32b

        uint           fromChainID, 32b
        uint           toChainID,   32b
        uint           fromAccountLen 8b
        uint           toAccountLen 8b

        bytes calldata fromAccount, slice
        bytes calldata toAccount    slice
        bytes calldata jettonAdminAddr 256b
-}

;; Constants
const int DICTIONARY_KEY_LEN = 32;

(cell) tm_load_data(cell ca_tm) impure {
    var ds = ca_tm.begin_parse();
    cell tokenPairs = ds~load_dict();
    ds.end_parse();
    return (tokenPairs);
}

(cell) tm_generate_data(cell tokenPair) impure {
    return begin_cell()
            .store_dict(tokenPair)
            .end_cell();
}


;; Helper functions for tokenPair struct
(int, slice, int, slice,slice,cell) load_tokenPair(slice cs) inline {
    var fromChainID = cs~load_uint(32);
    var toChainID = cs~load_uint(32);
    var fromAccountLen = cs~load_uint(8);
    var fromAccount = cs~load_bits(8 * fromAccountLen);
    var toAccountLen = cs~load_uint(8);
    var toAccount = cs~load_bits(8 * toAccountLen);
    var jettonAdminAddr = cs~load_bits(256);

    var walletCodeCell = cs~load_maybe_ref();
    return (fromChainID, fromAccount, toChainID, toAccount,jettonAdminAddr,walletCodeCell);
}


;; Get a tokenPair by ID
(int, slice, int, slice,slice,int,cell,slice) tm_get_token_pair(cell refcell, int id) method_id {
    slice tokenAccount = begin_cell().end_cell().begin_parse();
    cell tokenPairs = tm_load_data(refcell);
    if (cell_null?(tokenPairs)) {
        return (0, "", 0,"","",0,begin_cell().end_cell(),tokenAccount);
    }
    var (tokenPair_slice, found?) = tokenPairs.udict_get?(DICTIONARY_KEY_LEN, id);
    if (found?) {
        var (fromChainID, fromAccount, toChainID, toAccount, jettonAdminAddr, walletCodeCell) = load_tokenPair(tokenPair_slice);

        if (fromChainID == BIP44_CHAINID) {
            tokenAccount = fromAccount;
        } else {
            tokenAccount = toAccount;
        }
        return (fromChainID, fromAccount, toChainID, toAccount,jettonAdminAddr,-1,walletCodeCell,tokenAccount);
    } else {
        return (0, "", 0,"","",0,begin_cell().end_cell(),tokenAccount); ;; Return default values if not found
    }
}

;; Get a tokenPair by ID
;; (slice,int) tm_get_token_address(cell refcell, int id) method_id {
;;     (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr,int exist,_) = tm_get_token_pair(refcell, id);
;;     if ( exist  == 0 ){
;;         return ("",0);
;;     }
;;     slice tokenAccount = begin_cell().end_cell().begin_parse();
;;     if (srcChainId == BIP44_CHAINID) {
;;         tokenAccount = fromAccount;
;;     } else {
;;         tokenAccount = dstAccount;
;;     }
;;     return (tokenAccount,-1);
;; }


;; Get the first tokenPair in the dictionary
(int) tm_get_first_tokenpair_id(cell refcell) method_id {
    (cell tokenPairs) = tm_load_data(refcell);
    if (cell_null?(tokenPairs)) {
        return 0;
    }
    (int id, slice value, int success) = tokenPairs.udict_get_min?(DICTIONARY_KEY_LEN);
    if (success) {
        return id;
    } else {
        return 0;
    }
}
;; Get the first tokenPair in the dictionary
(int) tm_get_next_tokenpair_id(cell refcell, int id) method_id {
    (cell tokenPairs) = tm_load_data(refcell);
    if (cell_null?(tokenPairs)) {
        return 0;
    }
    (int id, slice value, int success) = tokenPairs.udict_get_next?(DICTIONARY_KEY_LEN, id);
    if (success) {
        return id;
    } else {
        return 0;
    }
}

;; Example of how to use in recv_internal
(cell) tm_recv_internal(int op, cell refcell, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    (cell tokenPairs) = tm_load_data(refcell);
    ~strdump("tm_recv_internal"); ~dump(op);

    if (op == OP_TOKENPAIR_Upsert) {
        ~strdump("111");
        int id = in_msg_body~load_uint(32);
        int fromChainID = in_msg_body~load_uint(32);
        int toChainID = in_msg_body~load_uint(32);
        int fromAccountLen = in_msg_body~load_uint(8);
        int toAccountLen = in_msg_body~load_uint(8);

        ~strdump("222");
        slice fromAccountSlice = in_msg_body~load_ref().begin_parse(); 
        slice fromAccount = fromAccountSlice~load_bits(8 * fromAccountLen);
        slice toAccountSlice = in_msg_body~load_ref().begin_parse();
        slice toAccount = toAccountSlice~load_bits(8 * toAccountLen);
        slice jettonAdminAddr = in_msg_body~load_bits(256);

        cell walletCode = in_msg_body~load_maybe_ref();

        ~strdump("333");
        tokenPairs~udict_set_builder(DICTIONARY_KEY_LEN, id, 
            begin_cell().store_uint(fromChainID, 32)
            .store_uint(toChainID, 32)
            .store_uint(fromAccountLen, 8)
            .store_slice(fromAccount)
            .store_uint(toAccountLen, 8)
            .store_slice(toAccount)
            .store_slice(jettonAdminAddr)
            .store_maybe_ref(walletCode)
        );
        ~strdump("444");
        return tm_generate_data(tokenPairs);
    }  ;; there  is no elseif 
    if (op == OP_TOKENPAIR_Remove) { ;; Delete tokenPair operation
        int id = in_msg_body~load_uint(32);
        tokenPairs~udict_delete?(DICTIONARY_KEY_LEN, id);
        return tm_generate_data(tokenPairs);
    }
    return refcell;
}