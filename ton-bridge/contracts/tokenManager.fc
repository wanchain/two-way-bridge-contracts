#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/const.fc";


{-
        uint    id,     32b

        uint           fromChainID, 32b
        uint           toChainID,   32b
        uint           fromAccountLen 8b
        uint           toAccountLen 8b

        bytes calldata fromAccount, slice
        bytes calldata toAccount    slice
        bytes calldata jettonAdminAddr 256b
-}


(cell) tm_load_data(cell ca_tm) impure {
    var ds = ca_tm.begin_parse();
    cell tokenPairs = ds~load_dict();
    ds.end_parse();
    return (tokenPairs);
}

(cell) tm_generate_data(cell tokenPair) impure {
    return begin_cell()
        .store_dict(tokenPair)
        .end_cell();
}

;; Helper functions for tokenPair struct
(int, slice, int, slice, cell) load_tokenPair(slice cs) inline {
    var fromChainID = cs~load_uint(32);
    var toChainID = cs~load_uint(32);
    var fromAccountLen = cs~load_uint(8);
    var fromAccount = cs~load_bits(8 * fromAccountLen);
    var toAccountLen = cs~load_uint(8);
    var toAccount = cs~load_bits(8 * toAccountLen);

    var walletCodeCell = cs~load_maybe_ref();
    return (fromChainID, fromAccount, toChainID, toAccount, walletCodeCell);
}


;; Get a tokenPair by ID
(int, slice, int, slice, int, cell, slice) tm_get_token_pair(cell refcell, int id) method_id {
    slice tokenAccount = begin_cell().end_cell().begin_parse();
    cell tokenPairs = tm_load_data(refcell);
    if (cell_null?(tokenPairs)) {
        return (0, "", 0, "", 0, begin_cell().end_cell(), tokenAccount);
    }
    var (tokenPair_slice, found?) = tokenPairs.udict_get?(DICTIONARY_KEY_LEN, id);
    if (found?) {
        var (fromChainID, fromAccount, toChainID, toAccount, walletCodeCell) = load_tokenPair(tokenPair_slice);

        if (fromChainID == BIP44_CHAINID) {
            tokenAccount = fromAccount;
        } else {
            tokenAccount = toAccount;
        }
        return (fromChainID, fromAccount, toChainID, toAccount, -1, walletCodeCell, tokenAccount);
    } else {
        return (0, "", 0, "", 0, begin_cell().end_cell(), tokenAccount); ;; Return default values if not found
    }
}

;; Get the first tokenPair in the dictionary
(int) tm_get_first_tokenpair_id(cell refcell) method_id {
    (cell tokenPairs) = tm_load_data(refcell);
    if (cell_null?(tokenPairs)) {
        return 0;
    }
    (int id, slice value, int success) = tokenPairs.udict_get_min?(DICTIONARY_KEY_LEN);
    if (success) {
        return id;
    } else {
        return 0;
    }
}
;; Get the first tokenPair in the dictionary
(int) tm_get_next_tokenpair_id(cell refcell, int id) method_id {
    (cell tokenPairs) = tm_load_data(refcell);
    if (cell_null?(tokenPairs)) {
        return 0;
    }
    (int id, slice value, int success) = tokenPairs.udict_get_next?(DICTIONARY_KEY_LEN, id);
    if (success) {
        return id;
    } else {
        return 0;
    }
}

;; Example of how to use in recv_internal
(cell) tm_recv_internal(int op, cell refcell, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    (cell tokenPairs) = tm_load_data(refcell);

    if (op == OP_TOKENPAIR_Upsert) {
        int id = in_msg_body~load_uint(32);
        int fromChainID = in_msg_body~load_uint(32);
        int toChainID = in_msg_body~load_uint(32);
        int fromAccountLen = in_msg_body~load_uint(8);
        int toAccountLen = in_msg_body~load_uint(8);

        slice fromAccountSlice = in_msg_body~load_ref().begin_parse();
        slice fromAccount = fromAccountSlice~load_bits(8 * fromAccountLen);
        slice toAccountSlice = in_msg_body~load_ref().begin_parse();
        slice toAccount = toAccountSlice~load_bits(8 * toAccountLen);

        cell walletCode = in_msg_body~load_maybe_ref();

        tokenPairs~udict_set_builder(DICTIONARY_KEY_LEN, id,
            begin_cell().store_uint(fromChainID, 32)
                .store_uint(toChainID, 32)
                .store_uint(fromAccountLen, 8)
                .store_slice(fromAccount)
                .store_uint(toAccountLen, 8)
                .store_slice(toAccount)
                .store_maybe_ref(walletCode)
        );
        return tm_generate_data(tokenPairs);
    }  ;; there  is no elseif 
    if (op == OP_TOKENPAIR_Remove) {
        ;; Delete tokenPair operation
        int id = in_msg_body~load_uint(32);
        tokenPairs~udict_delete?(DICTIONARY_KEY_LEN, id);
        return tm_generate_data(tokenPairs);
    }
    return refcell;
}