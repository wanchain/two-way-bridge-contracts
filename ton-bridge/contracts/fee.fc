#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/common/const.fc";


(slice, slice, cell, cell, cell) fee_load_data(cell refcell) impure {
    var ds = refcell.begin_parse();
    slice smgFeeProxy = ds~load_msg_addr();
    slice feeOperator = ds~load_msg_addr();
    cell tokenPairFee = ds~load_dict();
    cell contractFee = ds~load_dict();
    cell crossAdmin = ds~load_dict();
    ds.end_parse();
    return (smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
}

(cell) fee_generate_data(slice smgFeeProxy, slice feeOperator, cell tokenPairFee, cell contractFee, cell crossAdmin) impure {
    return begin_cell()
        .store_slice(smgFeeProxy)
        .store_slice(feeOperator)
        .store_dict(tokenPairFee)
        .store_dict(contractFee)
        .store_dict(crossAdmin)
        .end_cell();
}

(int) fee_isCrossAdmin(cell refcell, slice addr) impure {
    (slice smgFeeProxy, slice feeOperator, cell tokenPairFee, cell contractFee, cell crossAdmin) = fee_load_data(refcell);
    (_, int hash) = parse_std_addr(addr);
    (_, int success) = crossAdmin.udict_get?(CROSSADMIN_DICTIONARY_KEY_LEN, hash);
    if (success) {
        return 1;
    } else {
        return 0;
    }
}

;; Example of how to use in recv_internal
(cell) fee_recv_internal(int op, cell refcell, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    (slice smgFeeProxy, slice feeOperator, cell tokenPairFee, cell contractFee, cell crossAdmin) = fee_load_data(refcell);
    if (op == OP_FEE_SetSmgFeeProxy) {
        slice _smgFeeProxy = in_msg_body~load_msg_addr();
        return fee_generate_data(_smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    if (op == OP_FEE_SetFeeOperator) {
        slice _feeOperator = in_msg_body~load_msg_addr();
        return fee_generate_data(smgFeeProxy, _feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    if (op == OP_FEE_SetTokenPairFee) {
        int tpId = in_msg_body~load_uint(32);
        int fee = in_msg_body~load_uint(32);
        tokenPairFee~udict_set_builder(TOKENPAIR_DICTIONARY_KEY_LEN, tpId, begin_cell().store_int(fee, 32));
        return fee_generate_data(smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    if (op == OP_FEE_SetTokenPairFees) {
        int count = in_msg_body~load_uint(32); ;;TODO. only support 3 for cell size limit
        while (count > 0) {
            int tpId = in_msg_body~load_uint(32);
            int fee = in_msg_body~load_uint(32);
            tokenPairFee~udict_set_builder(TOKENPAIR_DICTIONARY_KEY_LEN, tpId, begin_cell().store_int(fee, 32));
            count -= 1;
        }
        return fee_generate_data(smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    if (op == OP_FEE_SetChainFee) {
        int fromChain = in_msg_body~load_uint(32);
        int toChain = in_msg_body~load_uint(32);
        int fee = in_msg_body~load_uint(64);
        int chainkey = 0;
        chainkey = (fromChain << 32) + toChain;
        contractFee~udict_set_builder(CHAINFEE_DICTIONARY_KEY_LEN, chainkey, begin_cell().store_int(fee, 64));
        return fee_generate_data(smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    if (op == OP_FEE_SetChainFees) {
        int count = in_msg_body~load_uint(32); ;;TODO. only support 3 for cell size limit
        while (count > 0) {
            int fromChain = in_msg_body~load_uint(32);
            int toChain = in_msg_body~load_uint(32);
            int fee = in_msg_body~load_uint(64);
            contractFee~udict_set_builder(CHAINFEE_DICTIONARY_KEY_LEN, (fromChain << 32) + toChain, begin_cell().store_int(fee, 64));
            count -= 1;
        }
        return fee_generate_data(smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    if (op == OP_FEE_AddCrossAdmin) {
        slice admin = in_msg_body~load_msg_addr();
        (int workchain, int hash) = parse_std_addr(admin);
        crossAdmin~udict_set_builder(CROSSADMIN_DICTIONARY_KEY_LEN, hash, begin_cell().store_int(1, 2));
        return fee_generate_data(smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    if (op == OP_FEE_DelCrossAdmin) {
        slice admin = in_msg_body~load_msg_addr();
        (int workchain, int hash) = parse_std_addr(admin);
        crossAdmin~udict_delete?(CROSSADMIN_DICTIONARY_KEY_LEN, hash);
        return fee_generate_data(smgFeeProxy, feeOperator, tokenPairFee, contractFee, crossAdmin);
    }
    return refcell;
}


;; Get the first tokenPair in the dictionary
(slice) fee_get_first_crossAdmin(cell refcell) method_id {
    (slice smgFeeProxy, slice feeOperator, cell tokenPairFee, cell contractFee, cell crossAdmin) = fee_load_data(refcell);
    (int id, slice value, int success) = crossAdmin.udict_get_min?(CROSSADMIN_DICTIONARY_KEY_LEN);
    if (success) {
        return begin_cell().store_uint(id, CROSSADMIN_DICTIONARY_KEY_LEN).end_cell().begin_parse();
    } else {
        return begin_cell().store_uint(0, CROSSADMIN_DICTIONARY_KEY_LEN).end_cell().begin_parse();
    }
}
;; Get the first tokenPair in the dictionary
(slice) fee_get_next_crossAdmin(cell refcell, slice adminAddr) method_id {
    (slice smgFeeProxy, slice feeOperator, cell tokenPairFee, cell contractFee, cell crossAdmin) = fee_load_data(refcell);
    slice admin = adminAddr~load_msg_addr();
    (int workchain, int hash) = parse_std_addr(admin);
    (int id, slice value, int success) = crossAdmin.udict_get_next?(CROSSADMIN_DICTIONARY_KEY_LEN, hash);
    if (success) {
        return begin_cell().store_uint(id, CROSSADMIN_DICTIONARY_KEY_LEN).end_cell().begin_parse();
    } else {
        return begin_cell().store_uint(0, CROSSADMIN_DICTIONARY_KEY_LEN).end_cell().begin_parse();
    }
}


(slice, slice) fee_get_config(cell refcell) method_id {
    (slice smgFeeProxy, slice feeOperator, _, _, _) = fee_load_data(refcell);
    return (smgFeeProxy, feeOperator);
}
(int) fee_get_tokenpair_fee(cell refCell, int tokenpairID) method_id {
    (_, _, cell tpFee, _, _) = fee_load_data(refCell);

    (slice cs, int find) = udict_get?(tpFee, 32, tokenpairID);
    if (find) {
        return (cs~load_uint(32));
    }
    return (0);
}
(int, int) fee_get_chain_fee(cell refCell, int _src_chain_id, int _dst_chain_id) method_id {
    (_, _, _, cell chainFee, _) = fee_load_data(refCell);
    int key_int = (_src_chain_id << 32) + _dst_chain_id;
    (slice cs, int find) = udict_get?(chainFee, 64, key_int);
    if (find) {
        return (cs~load_uint(32), cs~load_uint(32));
    }
    return (0, 0);
}
(int) fee_get(cell refCell, int tokenpairID, int _src_chain_id, int _dst_chain_id) method_id {
    int fee = 0;
    (int tpFee) = fee_get_tokenpair_fee(refCell, tokenpairID);
    if (tpFee == 0) {
        (int contracFee, int agentFee) = fee_get_chain_fee(refCell, _src_chain_id, _dst_chain_id);
        if (contracFee != 0) {
            fee = contracFee;
        }
    } else {
        fee = tpFee;
    }
    return (fee);
}
