#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "jetton/messages.func";
#include "jetton/jetton-utils.func";
#include "tokenManager.fc";
#include "jetton/op-codes.func";
#include "./oracle.fc";
#include "imports/signature/sig-header.fc";
#include "fee.fc";

const SEND_SELF_TRAN_VALUE = 400000000;

() send_fee_to_proxy(slice proxyAddress, int fee) impure {
    ~strdump("send_fee_to_proxy....");
    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
        .store_slice(proxyAddress)
        .store_coins(fee)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg, IGNORE_ERRORS + PAY_FEES_SEPARATELY);
    return ();

}

() send_error_code_to_self(int queryId,int errorCode) impure {
    ~strdump("Entering send_error_code_to_self");
    var errorCode = begin_cell()
        .store_uint(OP_CROSS_ERROR, 32)
        .store_uint(queryId, 64)
        .store_uint(errorCode, 256)
        .end_cell();

    var msg = begin_cell()
        .store_uint(msg_flag::bounceable, 6)
        .store_slice(my_address())
        .store_coins(SEND_SELF_TRAN_VALUE)
        .store_msgbody_prefix_ref(errorCode)
        .end_cell();
    send_raw_message(msg,PAY_FEES_SEPARATELY);
    return ();

}


() send_token(int queryId, int amount, slice toAddress, slice jwBridgeAddr, int fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    {--
    1. bridge send inter_transfer to JW_bridge address
    2. toAddress is not jetton wallet address
    -}

    cell transfer_request = begin_cell()
        .store_op(op::transfer)
        .store_query_id(queryId)
        .store_coins(amount)
        .store_slice(toAddress)
    ;;.store_slice(my_address())
        .store_slice(senderAddr)
        .store_maybe_ref(begin_cell().end_cell())   ;; customPayload
        .store_coins(fwdTonAmount)            ;; forward_amount, 4 bit if zero
        .store_maybe_ref(begin_cell().end_cell())   ;; forwardPayload
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(jwBridgeAddr)
        .store_coins(totalTonAmount)
        .store_msgbody_prefix_ref(transfer_request);
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; revert on errors

    return ();
}

() revert_token(int queryId, int amount, slice toAddress, slice jwBridgeAddr, int fwdTonAmount, int totalTonAmount, slice excessAddr) impure {
    {--
    1. bridge send inter_transfer to JW_bridge address
    2. toAddress is not jetton wallet address
    -}

    cell transfer_request = begin_cell()
        .store_op(op::transfer)
        .store_query_id(queryId)
        .store_coins(amount)
        .store_slice(toAddress)
        .store_slice(excessAddr)
        .store_maybe_ref(begin_cell().end_cell())   ;; customPayload
        .store_coins(fwdTonAmount)            ;; forward_amount, 4 bit if zero
        .store_maybe_ref(begin_cell().end_cell())   ;; forwardPayload
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(jwBridgeAddr)
        .store_coins(totalTonAmount)
        .store_msgbody_prefix_ref(transfer_request);
    send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS); ;; revert on errors

    return ();
}

() smgRelease_ton(int queryId, int releaseValue, int fee, slice userAccount, slice proxyAddress) impure {
    ~strdump("smgRelease_ton.....");
    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable)
        .store_slice(userAccount)
        .store_coins((releaseValue - fee))
        .store_msgbody_prefix_slice();
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY);
    send_fee_to_proxy(proxyAddress, fee);
    return ();
}

() smgRelease_org_jetton(int queryId, int releaseValue, int fee, slice userAccount, slice proxyAddress, slice jwBridgeAddr, fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    send_token(queryId, (releaseValue - fee), userAccount, jwBridgeAddr, fwdTonAmount, totalTonAmount, senderAddr);
    if ( fee > 0){
        send_token(queryId, fee, proxyAddress, jwBridgeAddr, fwdTonAmount, totalTonAmount, senderAddr);
    }
    return ();
}

() smgRelease_wrapped_jetton(int queryId, int releaseValue, int fee, slice userAccount, slice proxyAddress, slice jwBridgeAddr, int fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    smgRelease_org_jetton(queryId, releaseValue, fee, userAccount, proxyAddress, jwBridgeAddr, fwdTonAmount, totalTonAmount, senderAddr);
}

() userLock_ton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount, slice smgFeeProxy) impure {
    ~strdump("userLock_ton....");
    send_fee_to_proxy(smgFeeProxy, fee);
    return ();
}

() userLock_org_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount, slice smgFeeProxy) impure {
    ~strdump("userLock_org_jetton....");
    send_fee_to_proxy(smgFeeProxy, fee);
    return ();
}

() userLock_wrapped_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount, slice smgFeeProxy) impure {
    ~strdump("userLock_wrapped_jetton....");
    send_fee_to_proxy(smgFeeProxy, fee);
    return ();
}

(int) compute_hash(int currentChainId, int uniqueId, int tokenPairId, int value, int fee, slice tokenAccount, slice userAccount) {
    var msg = begin_cell()
        .store_uint(currentChainId, 64)
        .store_uint(uniqueId, 256)
        .store_uint(tokenPairId, 32)
        .store_uint(value, 256)
        .store_uint(fee, 256)
        .store_ref(begin_cell()
            .store_slice(userAccount)
            .store_slice(tokenAccount)
            .end_cell());

    ;;return slice_hash_keccak256(msg.begin_parse(), 1);
    return msg.end_cell().cell_hash();
}

(slice, int, cell,int) cross_recv_internal(int op, int queryId, cell tokenManager, int msgValue, cell inMsgFull, slice inMsgBody, cell oracle, cell caFee, slice senderAddr) impure {
    int refundValue = 0;
    int revertToken = 0;
    slice originAddress = begin_cell().end_cell().begin_parse();
    ~strdump("cross_recv_internal....");
    slice ZERO_ACCOUNT = begin_cell().store_int(0, 256).end_cell().begin_parse();
    ~dump(op);
    if (op == OP_CROSS_UserLock) {

        (int smgId, int tokenPairId, int crossValue, int userAccountLen) = (inMsgBody~load_uint(256), inMsgBody~load_uint(32), inMsgBody~load_uint(256), inMsgBody~load_uint(8));
        (slice userAccount) = inMsgBody~load_bits(8 * userAccountLen);

        (slice extraSlice) = inMsgBody~load_ref().begin_parse();
        (slice tokenAcountFromMsg, slice jwAddressSrc, slice jwAddressBridgeFromMsg) = (extraSlice~load_msg_addr(), extraSlice~load_msg_addr(), extraSlice~load_msg_addr());

        (slice extraSlice2) = inMsgBody~load_ref().begin_parse();
        originAddress = extraSlice2~load_msg_addr();

        int lockFee = extraSlice2~load_uint(256);

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr, int tokenPairExist, _,slice tokenAccount) = tm_get_token_pair(tokenManager, tokenPairId);
        throw_unless(error::tm_tokenpair_not_exist, tokenPairExist);

        int fee = 0;
        ~strdump("fee_get_tokenpair_fee....");
        fee = fee_get(caFee, tokenPairId, srcChainId, dstChainId);

        throw_unless(error::cross_invalid_lock_fee, lockFee == fee);
        ~strdump("fee_get_config....");
        (slice smgFeeProxy, _) = fee_get_config(caFee);
        ~dump(smgFeeProxy);


        int hashProxyFeeAddr = smgFeeProxy~load_uint(256);
        slice intProxyFeeAddr = get_serialized_address(WORKING_CHAINID, hashProxyFeeAddr);

        ~strdump("compare tokenAccount and ZERO_ACCOUNT....");
        if (equal_slices(tokenAccount, ZERO_ACCOUNT)) {
            throw_if(error::cross_ton_not_enough, (fee + crossValue) > msgValue);
            refundValue = msgValue - fee - crossValue;
            userLock_ton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount, intProxyFeeAddr);
        } else {

            ;; fake user lock handle
            ;; user send userLockToken directory, not from my_address()
            (_, int hashSender) = parse_std_addr(senderAddr);
            slice hashSenderSlice = int_to_slice(hashSender, 256);

            refundValue = msgValue - fee;  ;; for token, handle exception in op_notification. ;;tokenpair handle in op_notification
            (_, int hash) = parse_std_addr(my_address());
            slice myAddressHashSlice = int_to_slice(hash, 256);

            if (equal_slices(hashSenderSlice, myAddressHashSlice) == 0) {
                throw(error::cross_lock_token_invalid_sender);
            }

            if (equal_slices(jettonAdminAddr, myAddressHashSlice)) {
                userLock_wrapped_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount, intProxyFeeAddr);
            } else {
                userLock_org_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount, intProxyFeeAddr);
            }
        }
        return (originAddress, refundValue, oracle, revertToken);
    }

    if (op == OP_TRANSFER_NOTIFICATION) {
        ~strdump("entering OP_TRANSFER_NOTIFICATION...");
        (int jettonAmount, slice a) = (inMsgBody~load_coins(), inMsgBody~load_msg_addr());
        cell lockBody = inMsgBody~load_maybe_ref();
        slice lockBodySlice = lockBody.begin_parse();
        (_, int queryIdFromLockBody, _, int tokenPairId, int crossValue) =
        (lockBodySlice~load_uint(32), lockBodySlice~load_uint(64), lockBodySlice~load_uint(256), lockBodySlice~load_uint(32), lockBodySlice~load_uint(256));
        ;;~strdump("111");
        (slice extraSlice) = lockBodySlice~load_ref().begin_parse();
        (slice tokenAcountFromMsg, slice jwAddressSrc, slice jwAddressBridgeFromMsg) = (extraSlice~load_msg_addr(), extraSlice~load_msg_addr(), extraSlice~load_msg_addr());
        ;;~strdump("222");
        (slice extraSlice2) = lockBodySlice~load_ref().begin_parse();
        slice originAddress = extraSlice2~load_msg_addr();
        int lockFee = extraSlice2~load_uint(256);
        ;;~strdump("333");
        if (queryIdFromLockBody != queryId) {
            ~strdump("444");
            ~strdump("queryId is not equal");
            (_, int hash) = parse_std_addr(jwAddressSrc);
            ~dump(hash);
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            ;;throw_arg("queryId not equal",error::cross_query_id_not_equal);
            send_error_code_to_self(queryId,error::cross_query_id_not_equal);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }
        if (jettonAmount != crossValue) {
            ~strdump("555");
            ;;send_token(queryId,jettonAmount,originAddress,jwAddressBridgeFromMsg,0,200000000,my_address());
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId,error::cross_invalid_jetton_amount);
            ;;throw_arg("jettonAmount is not equal to crossValue",error::cross_invalid_jetton_amount); ;;//
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr, int tokenPairExist, cell walletCode ,slice tokenAccount) = tm_get_token_pair(tokenManager, tokenPairId);
        int fee = fee_get(caFee, tokenPairId, srcChainId, dstChainId);

        if (fee > msgValue) {
            ~strdump("666");
            ;;throw_if(error::cross_ton_not_enough, fee  > msgValue );
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId,error::cross_ton_not_enough);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        ;; check tokenpair
        if (tokenPairExist == 0) {
            ~strdump("777");

            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId,error::tm_tokenpair_not_exist);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        (_, int tokenAcountFromMsgHash) =  parse_std_addr(tokenAcountFromMsg);
        slice tokenAcountFromMsgHashSlice = int_to_slice(tokenAcountFromMsgHash,256);
        if (equal_slice_bits(tokenAcountFromMsgHashSlice, tokenAccount) == 0) {
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId,error::cross_lock_token_account_error);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        ;; check sender is JettonWallet(my_address)
        slice jwAddrBridge = calc_user_wallet(my_address(), tokenAcountFromMsg, walletCode);

        if (equal_slice_bits(jwAddrBridge, senderAddr) == 0) {

            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId,error::cross_lock_token_invalid_sender);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }
        ;; send message to itself and invoke userLock
        var msg = begin_cell()
            .store_msg_flag(msg_flag::bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
            .store_slice(my_address())
            .store_coins(0)
            .store_msgbody_prefix_ref(lockBody);
        ~strdump("begin send userLock triggered by notification");
        send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);
        return (originAddress, refundValue, oracle, revertToken);
    }

    if (op == OP_CROSS_SmgRelease) {
        ;;(slice oracleAdmin, cell smgConfig, cell smgConfigCommit, cell smgTxUniqueId) = oracle_load_data(oracle);
        ~strdump("entering OP_CROSS_SmgRelease...");

        (slice smgFeeProxy, _) = fee_get_config(caFee);
        ~dump(smgFeeProxy);

        (int uniqId, int smgId, int tokenPairId, int releaseValue) = (inMsgBody~load_uint(256), inMsgBody~load_uint(256), inMsgBody~load_uint(32), inMsgBody~load_uint(256));

        slice part1 = inMsgBody~load_ref().begin_parse();
        (int fee, slice userAccount) = (part1~load_uint(256), part1~load_msg_addr());
        part1.end_parse();

        slice part2 = inMsgBody~load_ref().begin_parse();
        (int e, int p, int s) = (part2~load_uint(256), part2~load_uint(256), part2~load_uint(256));
        part2.end_parse();

        slice part3 = inMsgBody~load_ref().begin_parse();
        (slice jwBridgeAddr) = (part3~load_msg_addr());
        (int fwTonAmount, int totalTonAmount) = (part3~load_uint(256), part3~load_uint(256));
        part3.end_parse();

        ~strdump("before oracle_get_smg");
        (int gpk_x, int gpk_y, int start_time, int endTime, int timestamp) = oracle_get_smg(oracle, smgId, 0); ;; TODO, use commited.
        ~strdump("ssssssss oracle_get_smg"); ~dump(now()); ~dump(start_time); ~dump(endTime);
        throw_unless(error::oracle_out_time_range, (now() >= start_time) & (now() <= endTime));

        ~strdump("end oracle_get_smg");

        ;; check unique tx
        ~strdump("before oracle_handle_uniqid");
        var (new_oracle, unique_found?) = oracle_handle_uniqid(oracle, smgId, uniqId);
        ~strdump("after oracle_handle_uniqid");
        if (unique_found?) {
            ~strdump("duplicated......................................................");
            throw(error::cross_smg_release_duplicated_error);
        }

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr, int tokenPairExist, _,slice tokenAccount) = tm_get_token_pair(tokenManager, tokenPairId);
        throw_unless(error::tm_tokenpair_not_exist, tokenPairExist);

        ;; check signature
        ~strdump("before compute_hash");
        int msg_hash = compute_hash(BIP44_CHAINID, uniqId, tokenPairId, releaseValue, fee, tokenAccount, userAccount);
        ~strdump("end compute_hash");

        ~strdump("before verify_sec");
        throw_unless(error::signature_verify_error, verify_sec(s, gpk_x, gpk_y, e, p, msg_hash));
        ~strdump("after verify_sec");

        if (equal_slices(tokenAccount, ZERO_ACCOUNT)) {
            ~strdump("before entering smgRelease_ton...");
            smgRelease_ton(queryId, releaseValue, fee, userAccount, smgFeeProxy);
        } else {
            if (fee == 0) {
                refundValue = msgValue - totalTonAmount;
            } else {
                refundValue = msgValue - 2 * totalTonAmount;
            }
            (_, int hash) = parse_std_addr(my_address());
            slice myAddressHashSlice = int_to_slice(hash, 256);
            if (equal_slices(jettonAdminAddr, myAddressHashSlice)) {
                ~strdump("before entering smgRelease_wrapped_jetton...");
                smgRelease_wrapped_jetton(queryId, releaseValue, fee, userAccount, smgFeeProxy, jwBridgeAddr, fwTonAmount, totalTonAmount, senderAddr);
            } else {
                ~strdump("before entering smgRelease_org_jetton...");
                smgRelease_org_jetton(queryId, releaseValue, fee, userAccount, smgFeeProxy, jwBridgeAddr, fwTonAmount, totalTonAmount, senderAddr);
            }
        }
        return (originAddress, refundValue, new_oracle, revertToken);
    }

    if ( op == OP_CROSS_ERROR ) {
        ~strdump("Entering OP_CROSS_ERROR");
        int errorCode = inMsgBody~load_uint(256);
        ~dump(errorCode);
        throw(errorCode);
        return (originAddress, refundValue, oracle, revertToken);
    }

    throw(error::recv_unknown_opcode);
    return (originAddress, refundValue, oracle, revertToken);
}
