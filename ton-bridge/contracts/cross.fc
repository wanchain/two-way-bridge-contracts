#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "jetton/messages.func";
#include "tokenManager.fc";
#include "jetton/op-codes.func";
#include "./oracle.fc";
#include "imports/signature/sig-header.fc";
#include "fee.fc";

() smgRelease_ton(int queryId, int uniqId, int smgId, int tokenPairId, int releaseValue, int fee, slice tokenAccount, slice userAccount, int r, int p, int s, slice jwBridgeAddr) impure {
    ~strdump("smgRelease_ton.....");
    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(userAccount)
        .store_coins(releaseValue) ;;todo handle fee
        .store_msgbody_prefix_slice();
    send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS); ;; revert on errors
    ;;todo delete begin
    ;;throw(0x111);  ;; rollback ton to bridge if error occurs.
    ;;todo delete end
    return ();
}

() smgRelease_org_jetton(int queryId, int uniqId, int smgId, int tokenPairId, int releaseValue, int fee, slice tokenAccount, slice userAccount, int r, int p, int s, slice jwBridgeAddr) impure {
    {--
    1. bridge send inter_transfer to JW_bridge address
    -}
    int forward_ton_amount = 2;                         ;;todo get from input message
    int total_ton_amount = 200000000;                   ;;todo get from input message
    cell mint_request = begin_cell()
        .store_op(op::transfer).store_query_id(queryId)
        .store_coins(releaseValue).store_slice(userAccount)
        .store_slice(my_address())                  ;; todo check response address
        .store_maybe_ref(begin_cell().end_cell())   ;; customPayload
        .store_coins(forward_ton_amount)            ;; forward_amount, 4 bit if zero
        .store_maybe_ref(begin_cell().end_cell())   ;; forwardPayload
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(jwBridgeAddr)
        .store_coins(total_ton_amount)
        .store_msgbody_prefix_ref(mint_request);
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; revert on errors
    return ();
}

() smgRelease_wrapped_jetton(int queryId, int uniqId, int smgId, int tokenPairId, int releaseValue, int fee, slice tokenAccount, slice userAccount, int r, int p, int s, slice jwBridgeAddr) impure {
    {--
    1. bridge send mint message to tokenAccount
    -}
    int forward_ton_amount = 4000000;                   ;;todo get from input message
    int total_ton_amount = 5000000;
    int totalTonFee = 100000000;
    int fwdTonFee = 50000000;
    cell mint_request = begin_cell()
        .store_op(op::mint).store_query_id(queryId)
        .store_slice(userAccount)
        .store_coins(releaseValue)
        .store_coins(forward_ton_amount)
        .store_coins(total_ton_amount)
        .end_cell();


    var msg = begin_cell()
        .store_uint(0, 1)
        .store_uint(1, 1)
        .store_uint(1, 1)
        .store_uint(0, 1)
        .store_slice(my_address())
        .store_slice(tokenAccount)
        .store_coins(totalTonFee)
        .store_uint(0, 1)
        .store_coins(0)
        .store_coins(fwdTonFee)
        .store_uint(cur_lt(), 64)
        .store_uint(now(), 32)
        .store_uint(0, 1)
        .store_uint(1, 1)
        .store_ref(mint_request);

    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; revert on errors
    return ();
}

() send_fee_to_proxy(slice proxyAddress,int fee){
    ~strdump("send_fee_to_proxy....");
    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
        .store_slice(proxyAddress)
        .store_coins(fee);
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY);
}

() userLock_ton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount,slice smgFeeProxy) impure {
    ~strdump("userLock_ton....");
    send_fee_to_proxy(smgFeeProxy,fee);
    return ();
}

() userLock_org_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount, slice jwAddrSrc,slice jwAddrBridge,slice smgFeeProxy) impure {
    ~strdump("userLock_org_jetton....");
    send_fee_to_proxy(smgFeeProxy,fee);
    return ();
}

() userLock_wrapped_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount, slice jwAddrSrc,slice jwAddrBridge,slice smgFeeProxy) impure {
    ~strdump("userLock_wrapped_jetton....");
    send_fee_to_proxy(smgFeeProxy,fee);
    return ();
}

(int) compute_hash(int currentChainId, int uniqueId, int tokenPairId, int value, int fee, slice tokenAccount, slice userAccount) {
    var msg = begin_cell()
        .store_uint(currentChainId, 64)
        .store_uint(uniqueId, 256)
        .store_uint(tokenPairId, 32)
        .store_uint(value, 256)
        .store_uint(fee, 256)
        .store_ref(begin_cell()
            .store_slice(userAccount)
            .store_slice(tokenAccount)
            .end_cell());

    ;;return slice_hash_keccak256(msg.begin_parse(), 1);
    return msg.end_cell().cell_hash();
}

(cell) cross_recv_internal(int op, int queryId, cell tokenManager, int msgValue, cell inMsgFull, slice inMsgBody, cell oracle, cell caFee) impure {
    ~strdump("cross_recv_internal....");
    slice ZERO_ACCOUNT = begin_cell().store_int(0, 256).end_cell().begin_parse();
    ~dump(op);
    if (op == OP_CROSS_UserLock) {

        (int smgId, int tokenPairId, int crossValue, int userAccountLen) = (inMsgBody~load_uint(256), inMsgBody~load_uint(32), inMsgBody~load_uint(256), inMsgBody~load_uint(8));
        (slice userAccount) = inMsgBody~load_bits(8 * userAccountLen);

        (slice extraSlice) = inMsgBody~load_ref().begin_parse();
        (slice jettonAdminAddrFromMsg,slice jwAddressSrc, slice jwAddressBridge) = (extraSlice~load_msg_addr(),extraSlice~load_msg_addr(),extraSlice~load_msg_addr());
        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr) = tm_get_token_pair(tokenManager, tokenPairId);

        int fee = 0;
        ~strdump("fee_get_tokenpair_fee....");
        (int tpFee)= fee_get_tokenpair_fee(caFee,tokenPairId);
        if (tpFee == 0){
            (int contracFee,int agentFee)= fee_get_chain_fee(caFee,srcChainId,dstChainId);
            if (contracFee != 0){
                fee = contracFee;
            }
        } else {
            fee = tpFee;
        }
        ~strdump("fee_get_config....");
        (slice smgFeeProxy,_) = fee_get_config(caFee);
        ~dump(smgFeeProxy);
        slice tokenAccount = begin_cell().end_cell().begin_parse();
        if (srcChainId == BIP44_CHAINID) {
            ~strdump("srcChainId == BIP44_CHAINID....");
            tokenAccount = fromAccount;
        } else {
            if (dstChainId == BIP44_CHAINID) {
                ~strdump("dstChainId == BIP44_CHAINID....");
                tokenAccount = dstAccount;
            } else {
                ~strdump("No chainID == BIP44_CHAINID....");
                ;;todo throw error   error tokenpairId, no ton bip44 chainID
                ;;todo send back jetton to srcUser
            }
        }
        ~strdump("jettonAdminAddr");
        ~dump(jettonAdminAddr);

        ~strdump("jettonAdminAddrFromMsg");
        ~dump(jettonAdminAddrFromMsg);

        (_, int hashJettonAdminAddrFromMsgHash) = parse_std_addr(jettonAdminAddrFromMsg);
        slice jettonAdminAddrFromMsgSlice = int_to_slice(hashJettonAdminAddrFromMsgHash, 256);

        if (equal_slices(jettonAdminAddr,jettonAdminAddrFromMsgSlice) != -1){
            ;;todo send back jetton to srcUser
            throw_arg("consistent with jettonAdminAddr",0xffff);
        }

        int hashProxyFeeAddr = smgFeeProxy~load_uint(256);
        slice intProxyFeeAddr = get_serialized_address(WORKING_CHAINID, hashProxyFeeAddr);

        ~strdump("compare tokenAccount and ZERO_ACCOUNT....");
        if (equal_slices(tokenAccount, ZERO_ACCOUNT)) {
            userLock_ton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount,intProxyFeeAddr);
        } else {
            int hash = tokenAccount~load_uint(256);
            slice tokenAccountInt = get_serialized_address(WORKING_CHAINID, hash);

            int hashJwSrc = jwAddressSrc~load_uint(256);
            slice jwSrcAccountInt = get_serialized_address(WORKING_CHAINID, hashJwSrc);

            int hashJwBridge = jwAddressBridge~load_uint(256);
            slice jwBridgeAccountInt = get_serialized_address(WORKING_CHAINID, hashJwBridge);

            (_, hash) = parse_std_addr(my_address());
            slice myAddressHashSlice = int_to_slice(hash, 256);
            if (equal_slices(jettonAdminAddr, myAddressHashSlice)) {
                userLock_org_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccountInt, userAccount, jwSrcAccountInt,jwBridgeAccountInt,intProxyFeeAddr);
            } else {
                userLock_wrapped_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccountInt, userAccount, jwSrcAccountInt,jwBridgeAccountInt,intProxyFeeAddr);
            }
        }
        return oracle;
    }

    if (op == OP_TRANSFER_NOTIFICATION) {
        ~strdump("entering OP_TRANSFER_NOTIFICATION...");
        (int jettonAmount,slice fromAddress ) = (inMsgBody~load_coins(),inMsgBody~load_msg_addr());
        cell lockBody = inMsgBody~load_maybe_ref();
        slice lockBodySlice = lockBody.begin_parse();
        (_, int queryIdFromLockBody,_,_,int crossValue) =
        (lockBodySlice~load_uint(32),lockBodySlice~load_uint(64),lockBodySlice~load_uint(256),lockBodySlice~load_uint(32),lockBodySlice~load_uint(256));
        if ( queryIdFromLockBody != queryId){
            throw_arg("query not equal",0xffff);
        }
        if ( jettonAmount != crossValue){
            throw_arg("jettonAmount is not equal to crossValue",0xffff); ;;//
        }

        ;; send message to itself and invoke userLock
        var msg = begin_cell()
            .store_msg_flag(msg_flag::bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
            .store_slice(my_address())
            .store_coins(msgValue)
            .store_msgbody_prefix_ref(lockBody);
        send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);
        return oracle;
    }

    if (op == OP_CROSS_SmgRelease) {
        ;;(slice oracleAdmin, cell smgConfig, cell smgConfigCommit, cell smgTxUniqueId) = oracle_load_data(oracle);
        ~strdump("entering OP_CROSS_SmgRelease...");

        (int uniqId,int smgId,int tokenPairId,int releaseValue) =(inMsgBody~load_uint(256),inMsgBody~load_uint(256),inMsgBody~load_uint(32),inMsgBody~load_uint(256));

        slice part1 = inMsgBody~load_ref().begin_parse();
        (int fee,slice userAccount) =(part1~load_uint(256),part1~load_msg_addr());
        part1.end_parse();

        slice part2 = inMsgBody~load_ref().begin_parse();
        (int e,int p,int s) =(part2~load_uint(256),part2~load_uint(256),part2~load_uint(256));
        part2.end_parse();

        slice part3 = inMsgBody~load_ref().begin_parse();
        (slice jwBridgeAddr) =(part3~load_msg_addr());
        part3.end_parse();

        ~strdump("before oracle_get_smg");
        (int gpk_x, int gpk_y, int start_time, int endTime, int timestamp) = oracle_get_smg(oracle, smgId, 0); ;; TODO, use commited.
        ~strdump("ssssssss oracle_get_smg"); ~dump(now()); ~dump(start_time); ~dump(endTime);
        throw_unless(0xffed, (now() >= start_time) & (now() <= endTime));

        ~strdump("end oracle_get_smg");

        ;; check unique tx
        ~strdump("before oracle_handle_uniqid");
        var (new_oracle, unique_found?) = oracle_handle_uniqid(oracle, smgId, uniqId);
        ~strdump("after oracle_handle_uniqid");
        if (unique_found?) {
            ~strdump("duplicated......................................................");
            throw(0xffff);
        }

        ;; todo check the fee
        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr) = tm_get_token_pair(tokenManager, tokenPairId);

        slice tokenAccountFromTp = begin_cell().end_cell().begin_parse();
        if (srcChainId == BIP44_CHAINID) {
            tokenAccountFromTp = fromAccount;
        } else {
            if (dstChainId == BIP44_CHAINID) {
                tokenAccountFromTp = dstAccount;
            } else {
                ;;todo throw error
            }
        }

        ;; check signature
        ~strdump("before compute_hash");
        int msg_hash = compute_hash(BIP44_CHAINID, uniqId, tokenPairId, releaseValue, fee, tokenAccountFromTp, userAccount);
        ~strdump("end compute_hash");

        ~strdump("before verify_sec");
        throw_unless(0xffee, verify_sec(s, gpk_x, gpk_y, e, p, msg_hash));
        ~strdump("after verify_sec");

        if (equal_slices(tokenAccountFromTp, ZERO_ACCOUNT)) {
            ~strdump("before entering smgRelease_ton...");
            smgRelease_ton(queryId, uniqId, smgId, tokenPairId, releaseValue, fee, tokenAccountFromTp, userAccount, e, p, s, jwBridgeAddr);
        } else {

            int hash = tokenAccountFromTp~load_uint(256);
            slice tokenAccountInt = get_serialized_address(WORKING_CHAINID, hash);

            ;; todo get jetton_admin_addr from jetton_admin
            (_, hash) = parse_std_addr(my_address());
            slice myAddressHashSlice = int_to_slice(hash, 256);
            if (equal_slices(jettonAdminAddr, myAddressHashSlice)) {
                ~strdump("before entering smgRelease_wrapped_jetton...");
                smgRelease_wrapped_jetton(queryId, uniqId, smgId, tokenPairId, releaseValue, fee, tokenAccountInt, userAccount, e, p, s, jwBridgeAddr);
            } else {
                ~strdump("before entering smgRelease_org_jetton...");
                smgRelease_org_jetton(queryId, uniqId, smgId, tokenPairId, releaseValue, fee, tokenAccountInt, userAccount, e, p, s, jwBridgeAddr);
            }
        }
        return (new_oracle);
    }
    throw(0xffff);
    return (oracle);
}