#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "jetton/messages.func";
#include "tokenManager.fc";
#include "jetton/op-codes.func";
#include "./oracle.fc";
#include "imports/signature/sig-header.fc";

() smgRelease_ton(int queryId, int uniqId, int smgId, int tokenPairId, int releaseValue, int fee, slice tokenAccount, slice userAccount, int r, int p, int s, slice jwBridgeAddr) impure {
    ~strdump("smgRelease_ton.....");
    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(userAccount)
        .store_coins(releaseValue) ;;todo handle fee
        .store_msgbody_prefix_slice();
    send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS); ;; revert on errors
    ;;todo delete begin
    ;;throw(0x111);  ;; rollback ton to bridge if error occurs.
    ;;todo delete end
    return ();
}

() smgRelease_org_jetton(int queryId, int uniqId, int smgId, int tokenPairId, int releaseValue, int fee, slice tokenAccount, slice userAccount, int r, int p, int s, slice jwBridgeAddr) impure {
    {--
    1. bridge send inter_transfer to JW_bridge address
    -}
    int forward_ton_amount = 2;                         ;;todo get from input message
    int total_ton_amount = 200000000;                   ;;todo get from input message
    cell mint_request = begin_cell()
        .store_op(op::transfer).store_query_id(queryId)
        .store_coins(releaseValue).store_slice(userAccount)
        .store_slice(my_address())                  ;; todo check response address
        .store_maybe_ref(begin_cell().end_cell())   ;; customPayload
        .store_coins(forward_ton_amount)            ;; forward_amount, 4 bit if zero
        .store_maybe_ref(begin_cell().end_cell())   ;; forwardPayload
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(jwBridgeAddr)
        .store_coins(total_ton_amount)
        .store_msgbody_prefix_ref(mint_request);
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; revert on errors
    return ();
}

() smgRelease_wrapped_jetton(int queryId, int uniqId, int smgId, int tokenPairId, int releaseValue, int fee, slice tokenAccount, slice userAccount, int r, int p, int s, slice jwBridgeAddr) impure {
    {--
    1. bridge send mint message to tokenAccount
    -}
    int forward_ton_amount = 4000000;                   ;;todo get from input message
    int total_ton_amount = 5000000;
    int totalTonFee = 100000000;
    int fwdTonFee = 50000000;
    cell mint_request = begin_cell()
        .store_op(op::mint).store_query_id(queryId)
        .store_slice(userAccount)
        .store_coins(releaseValue)
        .store_coins(forward_ton_amount)
        .store_coins(total_ton_amount)
        .end_cell();


    var msg = begin_cell()
        .store_uint(0, 1)
        .store_uint(1, 1)
        .store_uint(1, 1)
        .store_uint(0, 1)
        .store_slice(my_address())
        .store_slice(tokenAccount)
        .store_coins(totalTonFee)
        .store_uint(0, 1)
        .store_coins(0)
        .store_coins(fwdTonFee)
        .store_uint(cur_lt(), 64)
        .store_uint(now(), 32)
        .store_uint(0, 1)
        .store_uint(1, 1)
        .store_ref(mint_request);

    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; revert on errors
    return ();
}

() userLock_ton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount) impure {
    return ();
}

() userLock_org_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount) impure {
    return ();
}

() userLock_wrapped_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount) impure {
    return ();
}

(int) compute_hash(int currentChainId, int uniqueId, int tokenPairId, int value, int fee, slice tokenAccount, slice userAccount) {
    var msg = begin_cell()
        .store_uint(currentChainId, 64)
        .store_uint(uniqueId, 256)
        .store_uint(tokenPairId, 32)
        .store_uint(value, 256)
        .store_uint(fee, 256)
        .store_ref(begin_cell()
            .store_slice(userAccount)
            .store_slice(tokenAccount)
            .end_cell());

    ;;return slice_hash_keccak256(msg.begin_parse(), 1);
    return msg.end_cell().cell_hash();
}

(cell) cross_recv_internal(int op, int queryId, cell tokenManager, int msgValue, cell inMsgFull, slice inMsgBody, cell oracle) impure {
    ~strdump("cross_recv_internal....");
    slice ZERO_ACCOUNT = begin_cell().store_int(0, 256).end_cell().begin_parse();

    if (op == OP_CROSS_UserLock) {
        throw(0x01); ;; todo should delete
        return oracle;

        (int smgId, int tokenPairId, int crossValue, slice userAccount) = (inMsgBody~load_uint(256), inMsgBody~load_uint(32), inMsgBody~load_uint(256), inMsgBody~load_msg_addr());

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr) = tm_get_token_pair(tokenManager, tokenPairId);

        slice tokenAccount = begin_cell().end_cell().begin_parse();
        if (srcChainId == BIP44_CHAINID) {
            tokenAccount = fromAccount;
        } else {
            if (dstChainId == BIP44_CHAINID) {
                tokenAccount = dstAccount;
            } else {
                ;;todo throw error
            }
        }

        int fee = 0;
        ;; todo get fee from the input message?
        if (equal_slices(tokenAccount, ZERO_ACCOUNT)) {
            userLock_ton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount);
        } else {
            ;; todo get jetton_admin_addr from jetton_admin
            if (-1) {
                userLock_org_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount);

            } else {
                userLock_wrapped_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount);

            }
        }
        return oracle;
    }

    if (op == OP_CROSS_SmgRelease) {
        ;;(slice oracleAdmin, cell smgConfig, cell smgConfigCommit, cell smgTxUniqueId) = oracle_load_data(oracle);
        ~strdump("entering OP_CROSS_SmgRelease...");

        (int uniqId,int smgId,int tokenPairId,int releaseValue) =(inMsgBody~load_uint(256),inMsgBody~load_uint(256),inMsgBody~load_uint(32),inMsgBody~load_uint(256));

        slice part1 = inMsgBody~load_ref().begin_parse();
        (int fee,slice userAccount) =(part1~load_uint(256),part1~load_msg_addr());
        part1.end_parse();

        slice part2 = inMsgBody~load_ref().begin_parse();
        (int e,int p,int s) =(part2~load_uint(256),part2~load_uint(256),part2~load_uint(256));
        part2.end_parse();

        slice part3 = inMsgBody~load_ref().begin_parse();
        (slice jwBridgeAddr) =(part3~load_msg_addr());
        part3.end_parse();

        ~strdump("before oracle_get_smg");
        (int gpk_x, int gpk_y, int start_time, int endTime, int timestamp) = oracle_get_smg(oracle, smgId, 0); ;; TODO, use commited.
        ~strdump("ssssssss oracle_get_smg"); ~dump(now()); ~dump(start_time); ~dump(endTime);
        throw_unless(0xffed, (now() >= start_time) & (now() <= endTime));

        ~strdump("end oracle_get_smg");

        ;; check unique tx
        ~strdump("before oracle_handle_uniqid");
        var (new_oracle, unique_found?) = oracle_handle_uniqid(oracle, smgId, uniqId);
        ~strdump("after oracle_handle_uniqid");
        if (unique_found?) {
            ~strdump("duplicated......................................................");
            throw(0xffff);
        }

        ;; todo check the fee
        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr) = tm_get_token_pair(tokenManager, tokenPairId);

        slice tokenAccountFromTp = begin_cell().end_cell().begin_parse();
        if (srcChainId == BIP44_CHAINID) {
            tokenAccountFromTp = fromAccount;
        } else {
            if (dstChainId == BIP44_CHAINID) {
                tokenAccountFromTp = dstAccount;
            } else {
                ;;todo throw error
            }
        }

        ;; check signature
        ~strdump("before compute_hash");
        int msg_hash = compute_hash(BIP44_CHAINID, uniqId, tokenPairId, releaseValue, fee, tokenAccountFromTp, userAccount);
        ~strdump("end compute_hash");

        ~strdump("before verify_sec");
        throw_unless(0xffee, verify_sec(s, gpk_x, gpk_y, e, p, msg_hash));
        ~strdump("after verify_sec");

        if (equal_slices(tokenAccountFromTp, ZERO_ACCOUNT)) {
            ~strdump("before entering smgRelease_ton...");
            smgRelease_ton(queryId, uniqId, smgId, tokenPairId, releaseValue, fee, tokenAccountFromTp, userAccount, e, p, s, jwBridgeAddr);
        } else {

            int hash = tokenAccountFromTp~load_uint(256);
            slice tokenAccountInt = get_serialized_address(WORKING_CHAINID, hash);

            ;; todo get jetton_admin_addr from jetton_admin
            (_, hash) = parse_std_addr(my_address());
            slice myAddressHashSlice = int_to_slice(hash, 256);
            if (equal_slices(jettonAdminAddr, myAddressHashSlice)) {
                ~strdump("before entering smgRelease_wrapped_jetton...");
                smgRelease_wrapped_jetton(queryId, uniqId, smgId, tokenPairId, releaseValue, fee, tokenAccountInt, userAccount, e, p, s, jwBridgeAddr);
            } else {
                ~strdump("before entering smgRelease_org_jetton...");
                smgRelease_org_jetton(queryId, uniqId, smgId, tokenPairId, releaseValue, fee, tokenAccountInt, userAccount, e, p, s, jwBridgeAddr);
            }
        }
        return (new_oracle);
    }
    throw(0xffff);
    return (oracle);
}