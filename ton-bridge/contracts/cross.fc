#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "jetton/messages.func";
#include "tokenManager.fc";
#include "jetton/op-codes.func";
#include "./oracle.fc";
#include "imports/signature/sig-header.fc";
#include "fee.fc";

() send_fee_to_proxy(slice proxyAddress,int fee) impure {
    ~strdump("send_fee_to_proxy....");
   {- var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
        .store_slice(proxyAddress)
        .store_coins(fee);
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY);
    return ();-}


    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
        .store_slice(proxyAddress)
        .store_coins(fee)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg,PAY_FEES_SEPARATELY);
    return ();

}


() send_token(int queryId, int amount, slice toAddress , slice jwBridgeAddr, int fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    {--
    1. bridge send inter_transfer to JW_bridge address
    -}

    cell transfer_request = begin_cell()
        .store_op(op::transfer)
        .store_query_id(queryId)
        .store_coins( amount)
        .store_slice(toAddress)
        ;;.store_slice(my_address())
        .store_slice(senderAddr)
        .store_maybe_ref(begin_cell().end_cell())   ;; customPayload
        .store_coins(fwdTonAmount)            ;; forward_amount, 4 bit if zero
        .store_maybe_ref(begin_cell().end_cell())   ;; forwardPayload
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(jwBridgeAddr)
        .store_coins(totalTonAmount)
        .store_msgbody_prefix_ref(transfer_request);
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; revert on errors

    return ();
}

() smgRelease_ton(int queryId, int releaseValue, int fee,slice userAccount, slice proxyAddress) impure {
    ~strdump("smgRelease_ton.....");
    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable)
        .store_slice(userAccount)
        .store_coins(( releaseValue - fee ) )
        .store_msgbody_prefix_slice();
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY);
    send_fee_to_proxy(proxyAddress,fee);
    return ();
}

() smgRelease_org_jetton(int queryId, int releaseValue, int fee,slice userAccount, slice proxyAddress, slice jwBridgeAddr,fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    send_token( queryId, ( releaseValue - fee ),  userAccount , jwBridgeAddr, fwdTonAmount, totalTonAmount, senderAddr);
    send_token( queryId, fee ,  proxyAddress , jwBridgeAddr, fwdTonAmount, totalTonAmount, senderAddr);
    return ();
}

() smgRelease_wrapped_jetton(int queryId, int releaseValue, int fee,slice userAccount, slice proxyAddress, slice jwBridgeAddr ,int fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    smgRelease_org_jetton( queryId,  releaseValue,  fee, userAccount,  proxyAddress,  jwBridgeAddr,fwdTonAmount,totalTonAmount, senderAddr);
}

() userLock_ton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount,slice smgFeeProxy) impure {
    ~strdump("userLock_ton....");
    send_fee_to_proxy(smgFeeProxy,fee);
    return ();
}

() userLock_org_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount,slice smgFeeProxy) impure {
    ~strdump("userLock_org_jetton....");
    send_fee_to_proxy(smgFeeProxy,fee);
    return ();
}

() userLock_wrapped_jetton(int queryId, int smgId, int tokenPairId, int lockValue, int fee, slice tokenAccount, slice userAccount, slice smgFeeProxy) impure {
    ~strdump("userLock_wrapped_jetton....");
    send_fee_to_proxy(smgFeeProxy,fee);
    return ();
}

(int) compute_hash(int currentChainId, int uniqueId, int tokenPairId, int value, int fee, slice tokenAccount, slice userAccount) {
    var msg = begin_cell()
        .store_uint(currentChainId, 64)
        .store_uint(uniqueId, 256)
        .store_uint(tokenPairId, 32)
        .store_uint(value, 256)
        .store_uint(fee, 256)
        .store_ref(begin_cell()
            .store_slice(userAccount)
            .store_slice(tokenAccount)
            .end_cell());

    ;;return slice_hash_keccak256(msg.begin_parse(), 1);
    return msg.end_cell().cell_hash();
}

(slice, int,cell) cross_recv_internal(int op, int queryId, cell tokenManager, int msgValue, cell inMsgFull, slice inMsgBody, cell oracle, cell caFee, slice senderAddr) impure {
    int refundValue = 0;
    slice originAddress = begin_cell().end_cell().begin_parse();
    ~strdump("cross_recv_internal....");
    slice ZERO_ACCOUNT = begin_cell().store_int(0, 256).end_cell().begin_parse();
    ~dump(op);
    if (op == OP_CROSS_UserLock) {

        (int smgId, int tokenPairId, int crossValue, int userAccountLen) = (inMsgBody~load_uint(256), inMsgBody~load_uint(32), inMsgBody~load_uint(256), inMsgBody~load_uint(8));
        (slice userAccount) = inMsgBody~load_bits(8 * userAccountLen);

        (slice extraSlice) = inMsgBody~load_ref().begin_parse();
        (slice tokenAcountFromMsg,slice jwAddressSrc, slice jwAddressBridge) = (extraSlice~load_msg_addr(),extraSlice~load_msg_addr(),extraSlice~load_msg_addr());

        (slice extraSlice2) = inMsgBody~load_ref().begin_parse();
        originAddress = extraSlice2~load_msg_addr();
        int lockFee = extraSlice2~load_uint(256);

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr) = tm_get_token_pair(tokenManager, tokenPairId);

        int fee = 0;
        ~strdump("fee_get_tokenpair_fee....");
        (int tpFee)= fee_get_tokenpair_fee(caFee,tokenPairId);
        if (tpFee == 0){
            (int contracFee,int agentFee)= fee_get_chain_fee(caFee,srcChainId,dstChainId);
            if (contracFee != 0){
                fee = contracFee;
            }
        } else {
            fee = tpFee;
        }

        throw_unless(error::cross_invalid_lock_fee,lockFee == fee );
        ~strdump("fee_get_config....");
        (slice smgFeeProxy,_) = fee_get_config(caFee);
        ~dump(smgFeeProxy);
        slice tokenAccount = begin_cell().end_cell().begin_parse();
        if (srcChainId == BIP44_CHAINID) {
            ~strdump("srcChainId == BIP44_CHAINID....");
            tokenAccount = fromAccount;
        } else {
            if (dstChainId == BIP44_CHAINID) {
                ~strdump("dstChainId == BIP44_CHAINID....");
                tokenAccount = dstAccount;
            } else {
                ~strdump("No chainID == BIP44_CHAINID....");
                throw_arg("No chainID == BIP44_CHAINID",error::cross_invalid_chainid);
            }
        }

        int hashProxyFeeAddr = smgFeeProxy~load_uint(256);
        slice intProxyFeeAddr = get_serialized_address(WORKING_CHAINID, hashProxyFeeAddr);

        ~strdump("compare tokenAccount and ZERO_ACCOUNT....");
        if (equal_slices(tokenAccount, ZERO_ACCOUNT)) {
            refundValue = msgValue - fee - crossValue ;
            userLock_ton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount,intProxyFeeAddr);
        } else {
            refundValue = msgValue - fee ;
            (_, int hash) = parse_std_addr(my_address());
            slice myAddressHashSlice = int_to_slice(hash, 256);
            if (equal_slices(jettonAdminAddr, myAddressHashSlice)) {
                userLock_wrapped_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount, intProxyFeeAddr);
            } else {
                userLock_org_jetton(queryId, smgId, tokenPairId, crossValue, fee, tokenAccount, userAccount, intProxyFeeAddr);
            }
        }
        return (originAddress,refundValue,oracle);
    }

    if (op == OP_TRANSFER_NOTIFICATION) {
        ~strdump("entering OP_TRANSFER_NOTIFICATION...");
        (int jettonAmount,slice fromAddress ) = (inMsgBody~load_coins(),inMsgBody~load_msg_addr());
        cell lockBody = inMsgBody~load_maybe_ref();
        slice lockBodySlice = lockBody.begin_parse();
        (_, int queryIdFromLockBody,_,_,int crossValue) =
        (lockBodySlice~load_uint(32),lockBodySlice~load_uint(64),lockBodySlice~load_uint(256),lockBodySlice~load_uint(32),lockBodySlice~load_uint(256));
        if ( queryIdFromLockBody != queryId){
            throw_arg("queryId not equal",error::cross_query_id_not_equal);
        }
        if ( jettonAmount != crossValue){
            throw_arg("jettonAmount is not equal to crossValue",error::cross_invalid_jetton_amount); ;;//
        }

        ;; send message to itself and invoke userLock
        var msg = begin_cell()
            .store_msg_flag(msg_flag::bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
            .store_slice(my_address())
            .store_coins(0)
            .store_msgbody_prefix_ref(lockBody);
        ~strdump("begin send userLock triggered by notification");
        send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);
        return (originAddress,refundValue,oracle);
    }

    ;; if (op == OP_EXCESSES) {
    ;;     return (oracle);
    ;; }

    if (op == OP_CROSS_SmgRelease) {
        ;;(slice oracleAdmin, cell smgConfig, cell smgConfigCommit, cell smgTxUniqueId) = oracle_load_data(oracle);
        ~strdump("entering OP_CROSS_SmgRelease...");

        (slice smgFeeProxy,_) = fee_get_config(caFee);
        ~dump(smgFeeProxy);

        (int uniqId,int smgId,int tokenPairId,int releaseValue) =(inMsgBody~load_uint(256),inMsgBody~load_uint(256),inMsgBody~load_uint(32),inMsgBody~load_uint(256));

        slice part1 = inMsgBody~load_ref().begin_parse();
        (int fee,slice userAccount) =(part1~load_uint(256),part1~load_msg_addr());
        part1.end_parse();

        slice part2 = inMsgBody~load_ref().begin_parse();
        (int e,int p,int s) =(part2~load_uint(256),part2~load_uint(256),part2~load_uint(256));
        part2.end_parse();

        slice part3 = inMsgBody~load_ref().begin_parse();
        (slice jwBridgeAddr) =(part3~load_msg_addr());
        (int fwTonAmount, int totalTonAmount) = (part3~load_uint(256),part3~load_uint(256));
        part3.end_parse();

        ~strdump("before oracle_get_smg");
        (int gpk_x, int gpk_y, int start_time, int endTime, int timestamp) = oracle_get_smg(oracle, smgId, 0); ;; TODO, use commited.
        ~strdump("ssssssss oracle_get_smg"); ~dump(now()); ~dump(start_time); ~dump(endTime);
        throw_unless(error::oracle_out_time_range, (now() >= start_time) & (now() <= endTime));

        ~strdump("end oracle_get_smg");

        ;; check unique tx
        ~strdump("before oracle_handle_uniqid");
        var (new_oracle, unique_found?) = oracle_handle_uniqid(oracle, smgId, uniqId);
        ~strdump("after oracle_handle_uniqid");
        if (unique_found?) {
            ~strdump("duplicated......................................................");
            throw(0xffff);
        }

        ;; todo check the fee
        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, slice jettonAdminAddr) = tm_get_token_pair(tokenManager, tokenPairId);

        slice tokenAccountFromTp = begin_cell().end_cell().begin_parse();
        if (srcChainId == BIP44_CHAINID) {
            tokenAccountFromTp = fromAccount;
        } else {
            if (dstChainId == BIP44_CHAINID) {
                tokenAccountFromTp = dstAccount;
            } else {
                throw_arg("invalid tokenPairID",error::cross_invalid_tokenpair_id);
            }
        }

        ;; check signature
        ~strdump("before compute_hash");
        int msg_hash = compute_hash(BIP44_CHAINID, uniqId, tokenPairId, releaseValue, fee, tokenAccountFromTp, userAccount);
        ~strdump("end compute_hash");

        ~strdump("before verify_sec");
        throw_unless(0xffee, verify_sec(s, gpk_x, gpk_y, e, p, msg_hash));
        ~strdump("after verify_sec");

        if (equal_slices(tokenAccountFromTp, ZERO_ACCOUNT)) {
            ~strdump("before entering smgRelease_ton...");
            smgRelease_ton(queryId,releaseValue, fee, userAccount, smgFeeProxy);
        } else {
            if ( fee == 0 ){
                refundValue = msgValue - totalTonAmount;
            } else {
                refundValue = msgValue - 2 * totalTonAmount;
            }
            (_, int hash) = parse_std_addr(my_address());
            slice myAddressHashSlice = int_to_slice(hash, 256);
            if (equal_slices(jettonAdminAddr, myAddressHashSlice)) {
                ~strdump("before entering smgRelease_wrapped_jetton...");
                smgRelease_wrapped_jetton(queryId,releaseValue, fee, userAccount,smgFeeProxy,jwBridgeAddr, fwTonAmount,totalTonAmount,senderAddr);
            } else {
                ~strdump("before entering smgRelease_org_jetton...");
                smgRelease_org_jetton(queryId,releaseValue, fee, userAccount, smgFeeProxy, jwBridgeAddr, fwTonAmount, totalTonAmount, senderAddr);
            }
        }
        return (originAddress,refundValue,new_oracle);
    }

    throw(0xffff);
    return (originAddress,refundValue,oracle);
}