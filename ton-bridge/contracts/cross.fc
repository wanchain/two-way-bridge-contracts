#pragma version >=0.2.0;

#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "jetton/messages.func";
#include "jetton/jetton-utils.func";
#include "tokenManager.fc";
#include "jetton/op-codes.func";
#include "./oracle.fc";
#include "imports/signature/sig-header.fc";
#include "fee.fc";

const SEND_SELF_TRAN_VALUE = 400000000;
const SEND_NORMAL_TRAN_VALUE = 300000000;
const PARTNER_LEN = 8;

() send_fee_to_proxy(slice proxyAddress, int fee) impure {
    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
        .store_slice(proxyAddress)
        .store_coins(fee)
        .store_msgbody_prefix_slice()
        .end_cell();
    send_raw_message(msg, PAY_FEES_SEPARATELY);
    return ();

}

() send_error_code_to_self(int queryId, int errorCode) impure {
    var errorCode = begin_cell()
        .store_uint(OP_CROSS_ERROR, 32)
        .store_uint(queryId, 64)
        .store_uint(errorCode, 256)
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(my_address())
        .store_coins(SEND_SELF_TRAN_VALUE)
        .store_msgbody_prefix_ref(errorCode)
        .end_cell();
    send_raw_message(msg, PAY_FEES_SEPARATELY);
    return ();

}

() send_token(int queryId, int amount, slice toAddress, slice jwBridgeAddr, int fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    {--
    1. bridge send inter_transfer to JW_bridge address
    2. toAddress is not jetton wallet address
    -}

    cell transfer_request = begin_cell()
        .store_op(op::transfer)
        .store_query_id(queryId)
        .store_coins(amount)
        .store_slice(toAddress)
    ;;.store_slice(my_address())
        .store_slice(senderAddr)
        .store_maybe_ref(begin_cell().end_cell())   ;; customPayload
        .store_coins(fwdTonAmount)            ;; forward_amount, 4 bit if zero
        .store_maybe_ref(begin_cell().end_cell())   ;; forwardPayload
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(jwBridgeAddr)
        .store_coins(totalTonAmount)
        .store_msgbody_prefix_ref(transfer_request);
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; revert on errors

    return ();
}

() revert_token(int queryId, int amount, slice toAddress, slice jwBridgeAddr, int fwdTonAmount, int totalTonAmount, slice excessAddr) impure {
    {--
    1. bridge send inter_transfer to JW_bridge address
    2. toAddress is not jetton wallet address
    -}

    cell transfer_request = begin_cell()
        .store_op(op::transfer)
        .store_query_id(queryId)
        .store_coins(amount)
        .store_slice(toAddress)
        .store_slice(excessAddr)
        .store_maybe_ref(begin_cell().end_cell())   ;; customPayload
        .store_coins(fwdTonAmount)            ;; forward_amount, 4 bit if zero
        .store_maybe_ref(begin_cell().end_cell())   ;; forwardPayload
        .end_cell();

    var msg = begin_cell()
        .store_msg_flag(msg_flag::bounceable)
        .store_slice(jwBridgeAddr)
        .store_coins(totalTonAmount)
        .store_msgbody_prefix_ref(transfer_request);
    send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS); ;; revert on errors

    return ();
}

() smgRelease_ton(int queryId, int releaseValue, int fee, slice userAccount, slice proxyAddress) impure {

    throw_if(error::cross_smg_release_ton_not_enough_error, get_balance().pair_first() < (releaseValue + fee + 2 * SEND_NORMAL_TRAN_VALUE));

    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable)
        .store_slice(userAccount)
        .store_coins(releaseValue)
        .store_msgbody_prefix_slice();
    send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY);
    send_fee_to_proxy(proxyAddress, fee);
    return ();
}


() smgRelease_jetton(int queryId, int releaseValue, int fee, slice userAccount, slice proxyAddress, slice jwBridgeAddr, fwdTonAmount, int totalTonAmount, slice senderAddr) impure {
    send_token(queryId, releaseValue, userAccount, jwBridgeAddr, fwdTonAmount, totalTonAmount, senderAddr);
    if (fee > 0) {
        send_token(queryId, fee, proxyAddress, jwBridgeAddr, fwdTonAmount, totalTonAmount, senderAddr);
    }
    return ();
}

() userLock_ton(int fee, slice smgFeeProxy) impure {
    send_fee_to_proxy(smgFeeProxy, fee);
    return ();
}

() userLock_jetton(int fee, slice smgFeeProxy) impure {
    send_fee_to_proxy(smgFeeProxy, fee);
    return ();
}

(int) compute_hash(int currentChainId, int uniqueId, int tokenPairId, int value, int fee, slice tokenAccount, slice userAccount) {
    var msg = begin_cell()
        .store_uint(currentChainId, 64)
        .store_uint(uniqueId, 256)
        .store_uint(tokenPairId, 32)
        .store_uint(value, 256)
        .store_uint(fee, 256)
        .store_ref(begin_cell()
            .store_slice(userAccount)
            .store_slice(tokenAccount)
            .end_cell());

    ;;return slice_hash_keccak256(msg.begin_parse(), 1);
    return msg.end_cell().cell_hash();
}

(slice, int, cell, int) cross_recv_internal(int op, int queryId, cell tokenManager, int msgValue, cell inMsgFull, slice inMsgBody, cell oracle, cell caFee, slice senderAddr) impure {
    int refundValue = 0;
    int revertToken = 0;
    slice originAddress = begin_cell().end_cell().begin_parse();
    slice ZERO_ACCOUNT = begin_cell().store_int(0, 256).end_cell().begin_parse();
    if (op == OP_CROSS_UserLock) {

        (int smgId, int tokenPairId, int crossValue, int userAccountLen) = (inMsgBody~load_uint(256), inMsgBody~load_uint(32), inMsgBody~load_uint(256), inMsgBody~load_uint(8));
        (slice userAccount) = inMsgBody~load_bits(8 * userAccountLen);

        (slice extraSlice) = inMsgBody~load_ref().begin_parse();
        (slice tokenAcountFromMsg, slice jwAddressSrc, slice jwAddressBridgeFromMsg) = (extraSlice~load_msg_addr(), extraSlice~load_msg_addr(), extraSlice~load_msg_addr());

        (slice extraSlice2) = inMsgBody~load_ref().begin_parse();
        originAddress = extraSlice2~load_msg_addr();

        int lockFee = extraSlice2~load_uint(256);
        (slice partner) = inMsgBody~load_bits(8 * PARTNER_LEN);

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, int tokenPairExist, _, slice tokenAccount) = tm_get_token_pair(tokenManager, tokenPairId);
        throw_unless(error::tm_tokenpair_not_exist, tokenPairExist);

        int fee = 0;
        fee = fee_get(caFee, tokenPairId, srcChainId, dstChainId);

        throw_unless(error::cross_invalid_lock_fee, lockFee == fee);
        (slice smgFeeProxy, _) = fee_get_config(caFee);


        int hashProxyFeeAddr = smgFeeProxy~load_uint(256);
        slice intProxyFeeAddr = get_serialized_address(WORKING_CHAINID, hashProxyFeeAddr);

        if (equal_slices(tokenAccount, ZERO_ACCOUNT)) {
            throw_if(error::cross_ton_not_enough, (fee + crossValue) > msgValue);
            refundValue = msgValue - fee - crossValue;
            userLock_ton(fee, intProxyFeeAddr);
        } else {

            ;; fake user lock handle
            ;; user send userLockToken directory, not from my_address()
            (_, int hashSender) = parse_std_addr(senderAddr);
            (_, int hash) = parse_std_addr(my_address());

            refundValue = msgValue - fee;  ;; for token, handle exception in op_notification. ;;tokenpair handle in op_notification
            ifnot (hash == hashSender) {
                throw(error::cross_lock_token_invalid_sender);
            }
            userLock_jetton(fee, intProxyFeeAddr);
        }
        return (originAddress, refundValue, oracle, revertToken);
    }

    if (op == OP_TRANSFER_NOTIFICATION) {
        (int jettonAmount, slice a) = (inMsgBody~load_coins(), inMsgBody~load_msg_addr());
        cell lockBody = inMsgBody~load_maybe_ref();
        slice lockBodySlice = lockBody.begin_parse();
        (_, int queryIdFromLockBody, _, int tokenPairId, int crossValue) =
        (lockBodySlice~load_uint(32), lockBodySlice~load_uint(64), lockBodySlice~load_uint(256), lockBodySlice~load_uint(32), lockBodySlice~load_uint(256));
        (slice extraSlice) = lockBodySlice~load_ref().begin_parse();
        (slice tokenAcountFromMsg, slice jwAddressSrc, slice jwAddressBridgeFromMsg) = (extraSlice~load_msg_addr(), extraSlice~load_msg_addr(), extraSlice~load_msg_addr());
        (slice extraSlice2) = lockBodySlice~load_ref().begin_parse();
        slice originAddress = extraSlice2~load_msg_addr();
        int lockFee = extraSlice2~load_uint(256);

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, int tokenPairExist, cell walletCode, slice tokenAccount) = tm_get_token_pair(tokenManager, tokenPairId);

        ;; check tokenpair
        if (tokenPairExist == 0) {
            ;;revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId, error::tm_tokenpair_not_exist);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        (_, int tokenAcountFromMsgHash) = parse_std_addr(tokenAcountFromMsg);
        slice tokenAcountFromMsgHashSlice = int_to_slice(tokenAcountFromMsgHash, 256);
        if (equal_slice_bits(tokenAcountFromMsgHashSlice, tokenAccount) == 0) {
            ;;revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId, error::cross_lock_token_account_error);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        ;; check sender is JettonWallet(my_address)
        slice jwAddrBridge = calc_user_wallet(my_address(), tokenAcountFromMsg, walletCode);
        (_, int hashSender) = parse_std_addr(senderAddr);
        (_, int hashJwAddrBridge) = parse_std_addr(jwAddrBridge);
        ifnot (hashSender == hashJwAddrBridge) {
            ;;revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId, error::cross_lock_token_invalid_sender);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        ;; check other parameters
        if (queryIdFromLockBody != queryId) {
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId, error::cross_query_id_not_equal);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }
        if (jettonAmount != crossValue) {
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId, error::cross_invalid_jetton_amount);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        ;; check fee
        int fee = fee_get(caFee, tokenPairId, srcChainId, dstChainId);

        if (fee > msgValue) {
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId, error::cross_ton_not_enough);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }
        ifnot (lockFee == fee) {
            revert_token(queryId, jettonAmount, originAddress, jwAddressBridgeFromMsg, 0, 0, originAddress);
            send_error_code_to_self(queryId, error::cross_invalid_lock_fee);
            revertToken = -1;
            return (originAddress, refundValue, oracle, revertToken);
        }

        ;; send message to itself and invoke userLock
        var msg = begin_cell()
            .store_msg_flag(msg_flag::bounceable) ;; we should not bounce here cause receiver can have uninitialized contract
            .store_slice(my_address())
            .store_coins(0)
            .store_msgbody_prefix_ref(lockBody);
        send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);
        return (originAddress, refundValue, oracle, revertToken);
    }

    if (op == OP_CROSS_SmgRelease) {
        ;;(slice oracleAdmin, cell smgConfig, cell smgConfigCommit, cell smgTxUniqueId) = oracle_load_data(oracle);

        (slice smgFeeProxy, _) = fee_get_config(caFee);

        (int uniqId, int smgId, int tokenPairId, int releaseValue) = (inMsgBody~load_uint(256), inMsgBody~load_uint(256), inMsgBody~load_uint(32), inMsgBody~load_uint(256));

        (int gpk_x, int gpk_y, int start_time, int endTime, int timestamp) = oracle_get_smg(oracle, smgId, 1);
        throw_if(error::oracle_not_found_smg, (gpk_x == 0) | (gpk_y == 0));
        throw_unless(error::oracle_out_time_range, (now() >= start_time) & (now() <= endTime));

        slice part1 = inMsgBody~load_ref().begin_parse();
        (int fee, slice userAccount) = (part1~load_uint(256), part1~load_msg_addr());
        part1.end_parse();

        slice part2 = inMsgBody~load_ref().begin_parse();
        (int e, int p, int s) = (part2~load_uint(256), part2~load_uint(256), part2~load_uint(256));
        part2.end_parse();

        slice part3 = inMsgBody~load_ref().begin_parse();
        (slice jwBridgeAddr) = (part3~load_msg_addr());
        (int fwTonAmount, int totalTonAmount) = (part3~load_uint(256), part3~load_uint(256));
        part3.end_parse();


        ;; check unique tx
        var (new_oracle, unique_found?) = oracle_handle_uniqid(oracle, smgId, uniqId);
        if (unique_found?) {
            throw(error::cross_smg_release_duplicated_error);
        }

        (int srcChainId, slice fromAccount, int dstChainId, slice dstAccount, int tokenPairExist, _, slice tokenAccount) = tm_get_token_pair(tokenManager, tokenPairId);
        throw_unless(error::tm_tokenpair_not_exist, tokenPairExist);

        ;; check signature
        int msg_hash = compute_hash(BIP44_CHAINID, uniqId, tokenPairId, releaseValue, fee, tokenAccount, userAccount);

        throw_unless(error::signature_verify_error, verify_sec(s, gpk_x, gpk_y, e, p, msg_hash));

        if (equal_slices(tokenAccount, ZERO_ACCOUNT)) {
            smgRelease_ton(queryId, releaseValue, fee, userAccount, smgFeeProxy);
        } else {
            ;; here the totalTonAmount value not from this contract, because it belongs the trans fee.
            if (fee == 0) {
                throw_unless(error::cross_ton_not_enough, msgValue > totalTonAmount);
                refundValue = msgValue - totalTonAmount;
            } else {
                throw_unless(error::cross_ton_not_enough, msgValue > 2 * totalTonAmount);
                refundValue = msgValue - 2 * totalTonAmount;
            }
            smgRelease_jetton(queryId, releaseValue, fee, userAccount, smgFeeProxy, jwBridgeAddr, fwTonAmount, totalTonAmount, senderAddr);
        }
        return (originAddress, refundValue, new_oracle, revertToken);
    }

    if (op == OP_CROSS_ERROR) {
        int errorCode = inMsgBody~load_uint(256);
        throw(errorCode);
        return (originAddress, refundValue, oracle, revertToken);
    }

    throw(error::recv_unknown_opcode);
    return (originAddress, refundValue, oracle, revertToken);
}
