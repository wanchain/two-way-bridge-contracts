#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "jetton/messages.func";
#include "jetton/op-codes.func";

#include "tokenManager.fc";
#include "fee.fc";
#include "extend.fc";
#include "oracle.fc";
#include "cross.fc";

;; load_data populates storage variables using stored data
(slice, int, int, cell, cell, cell, cell) load_data() impure {
    var ds = get_data().begin_parse();
    slice cross_owner = ds~load_msg_addr();
    (int halt, int init) = (ds~load_uint(2), ds~load_uint(2));
    (cell ca_fee, cell oracle, cell token_manager, cell extend) = (ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref());
    ds.end_parse();
    return (cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
}

;; save_data stores storage variables as a cell into persistent storage
() save_data(slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) impure {
    set_data(
        begin_cell()
            .store_slice(cross_owner)
            .store_uint(halt, 2)
            .store_uint(init, 2)
            .store_ref(ca_fee)
            .store_ref(oracle)
            .store_ref(token_manager)
            .store_ref(extend)
            .end_cell()
    );
}

{-(int, int, slice, slice) get_token_pair(int _token_paird_id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    slice tm_slice = token_manager.begin_parse();
    (cell tm_dic, cell wt_dic) = (tm_slice~load_dict(), tm_slice~load_dict());
    slice from_account = begin_cell().end_cell().begin_parse();
    slice to_account = begin_cell().end_cell().begin_parse();
    (cell dic_new, int ret) = udict_get_ref?(tm_dic, 32, _token_paird_id);
    if (cell_null?(dic_new)) {
        return (0, 0, from_account, to_account);
    }
    slice cs = dic_new.begin_parse();
    if (ret) {
        (int _src_chain_id, int _dst_chain_id, int _from_account_len) =
        (cs~load_uint(32), cs~load_uint(32), cs~load_uint(8));


        slice _from_account = cs~load_bits(8 * _from_account_len);
        int _to_account_len = cs~load_uint(8);
        slice _to_account = cs~load_bits(8 * _to_account_len);

        return (_src_chain_id, _dst_chain_id, _from_account, _to_account);
    }
    return (0, 0, from_account, to_account);
}-}

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee

    ;;todo should check the rights

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    if(op & 0xFF000000 == OP_COMMON) {
        if(op == OP_COMMON_SetHalt) {
            int _halt = in_msg_body~load_uint(2);
            save_data(cross_owner, _halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }
        if(op == OP_COMMON_Initialize) {
            int _init = in_msg_body~load_uint(2);
            save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }
        if(op == OP_COMMON_TransferOwner) {
            slice _cross_owner = in_msg_body~load_msg_addr();
            save_data(_cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }
    }

    if (op & 0xFF000000 == OP_CROSS) {
        ;; var _extend = cross_recv_internal(op, extend, msg_value, in_msg_full, in_msg_body);
        ;; save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, _extend);
        ~strdump("Entering op_cross...");
        cross_recv_internal(op, query_id, token_manager,msg_value, in_msg_full, in_msg_body);
        return ();
    }

    if (op & 0xFF000000 == OP_FEE) {
        var _ca_fee = fee_recv_internal(op, ca_fee, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, _ca_fee, oracle, token_manager, extend);
        return ();
    }

    if (op & 0xFF000000 == OP_ORACLE) {
        var _oracle = oracle_recv_internal(op, oracle, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, ca_fee, _oracle, token_manager, extend);
        return ();
    }

    if (op & 0xFF000000 == OP_TOKENPAIR) {
        var _token_manager = tm_recv_internal(op, token_manager, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, ca_fee, oracle, _token_manager, extend);
        return ();
    }

    if (op & 0xFF000000 == OP_EXTEND) {
        var _extend = ext_recv_internal(op, extend, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, _extend);
        return ();
    }

    if (op == OP_UPGRADE_Code) {
        var new_code = in_msg_body~load_ref();
        set_code(new_code);
        return ();
    }

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

(slice, int, int) get_cross_config() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return (cross_owner, halt, init);
}

;; getter for oracle
(int, int, int) get_smgConfig(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_smg(oracle, id);
}
(int, int) get_fee(int _src_chain_id, int _dst_chain_id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    ;;todo load smgFeeProxy first
    slice ca_fee_slice = ca_fee.begin_parse();
    (_, cell dict) = (ca_fee_slice~load_msg_addr(), ca_fee_slice~load_dict());
    slice key = begin_cell().store_uint(_src_chain_id, 32).store_uint(_dst_chain_id, 32).end_cell().begin_parse();
    int key_int = slice_to_int(key, 64);
    (slice cs, int ret) = udict_get?(dict, 64, key_int);
    if (ret) {
        return (cs~load_uint(32), cs~load_uint(32));
    }
    return (0, 0);
}
(int) get_first_smg_id() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_first_smg_id(oracle);
}
(int) get_next_smg_id(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_next_smg_id(oracle, id);
}

;; getter for tokenManager
(int, slice, int, slice) get_token_pair(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_token_pair(token_manager, id);
}
(int) get_first_tokenpair_id() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_first_tokenpair_id(token_manager);
}
(int) get_next_tokenpair_id(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_next_tokenpair_id(token_manager, id);
}

;; getter for extend
(slice) get_first_crossAdmin() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return ext_get_first_crossAdmin(extend);
}
(slice) get_next_crossAdmin(slice adminAddr) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return ext_get_next_crossAdmin(extend, adminAddr);
}

;; for test.
(int) get_updated_int() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return ext_get_updated_int(extend);
}

(slice) version() method_id {
    return "0.1";
}