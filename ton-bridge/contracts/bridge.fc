#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "jetton/messages.func";
#include "jetton/op-codes.func";

#include "tokenManager.fc";
#include "fee.fc";
#include "extend.fc";
#include "oracle.fc";
#include "cross.fc";

;; load_data populates storage variables using stored data
(slice, int, int, cell, cell, cell, cell) load_data() impure {
    var ds = get_data().begin_parse();
    slice cross_owner = ds~load_msg_addr();
    (int halt, int init) = (ds~load_uint(2), ds~load_uint(2));
    (cell ca_fee, cell oracle, cell token_manager, cell extend) = (ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref());
    ds.end_parse();
    return (cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
}

;; save_data stores storage variables as a cell into persistent storage
() save_data(slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) impure {
    set_data(
        begin_cell()
            .store_slice(cross_owner)
            .store_uint(halt, 2)
            .store_uint(init, 2)
            .store_ref(ca_fee)
            .store_ref(oracle)
            .store_ref(token_manager)
            .store_ref(extend)
            .end_cell()
    );
}


() cb_executed(slice sender_address, int query_id) impure {
    var msg = begin_cell()
        .store_uint(0x18, 6)     ;;
        .store_slice(sender_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(OP_COMMON_Finished, 32)
        .store_uint(query_id, 64)
        .end_cell();
    send_raw_message(msg,80);
    return ();
}
(int, int, int, int, int) get_smgConfigCommited(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_smg(oracle, id, 1);
}
() check_privilege(int op, slice sender_address, slice cross_owner, cell oracle, cell feeCell ) impure {
    ~strdump("check_privilege");
    ~dump(op);
    if(( op == OP_TRANSFER_NOTIFICATION ) | ( op == OP_EXCESSES )){
        return ();
    }

    if((op & 0xFF000000 == OP_CROSS) | (op == OP_FETCH_GPK)){
        return ();
    }
    if((op == OP_COMMON_TransferOwner) | (op == OP_COMMON_SetHalt)) {
        throw_unless(error::unauthorized_set_common_config, equal_slices(sender_address, cross_owner));
        return ();
    }
    if ((op == OP_FEE_SetSmgFeeProxy) | (op == OP_FEE_SetFeeOperator)) {
        throw_unless(error::unauthorized_set_fee_config, equal_slices(sender_address, cross_owner));
        return ();
    }
    if((op == OP_FEE_AddCrossAdmin) | (op == OP_FEE_DelCrossAdmin)) {
        throw_unless(error::unauthorized_set_fee_admin, equal_slices(sender_address, cross_owner));
        return ();
    }

    if ((op == OP_FEE_SetChainFee) | (op == OP_FEE_SetChainFees) | (op == OP_FEE_SetTokenPairFee) | (op == OP_FEE_SetTokenPairFees)) {
        (_, slice feeOperator) = fee_get_config(feeCell);
        if(equal_slices(sender_address, feeOperator)) {
            return ();
        }
        if( 1 == fee_isCrodsAdmin(feeCell, sender_address)) {
            return ();
        }
        throw(error::unauthorized_set_fee);
    }

    if(op == OP_ORACLE_TransferOracleAdmin) {
        throw_unless(error::unauthorized_transfer_oracle_admin, equal_slices(sender_address, cross_owner));
        return ();
    }

    if((op == OP_ORACLE_SetSMG) | (op == OP_ORACLE_CommitSMG) |(op == OP_ORACLE_DeleteSMG)) {
        slice oracleAdmin = oracle_get_OracleAdmin(oracle);
        throw_unless(error::unauthorized_set_oracle_smg, (equal_slices(sender_address, cross_owner) | equal_slices(sender_address, oracleAdmin)));
        return ();
    }
    if (op & 0xFF000000 == OP_TOKENPAIR) {
        throw_unless(error::unauthorized_set_tokenpair, equal_slices(sender_address, cross_owner));
        return ();
    }
    if (op == OP_UPGRADE_Code) {
        throw_unless(error::unauthorized_upgrade, equal_slices(sender_address, cross_owner));
        return ();
    }
    throw(error::privilege_unknown_opcode);
}
;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee

    ;;todo should check the rights

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    check_privilege(op, sender_address, cross_owner, oracle, ca_fee );
    if( op == OP_FETCH_GPK) {
        var smgID = in_msg_body~load_uint(256);
        ;; TODO, set gpk first
        ~strdump("OP_FETCH_GPK"); ~dump(smgID);
        (int gpkx, int gpky, int startTime, int endTime, int timestamp) = get_smgConfigCommited(smgID);
        ~strdump("OP_FETCH_GPK"); ~dump(gpkx);~dump(gpky);
        throw_unless(error::gpk_invalid_timestamp, (now() > startTime) & (now() < endTime));

        var msg = begin_cell()
            .store_uint(0x18, 6)     ;;
            .store_slice(sender_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(OP_GROUPAPPROVE_Execute_WithGPK, 32)
            .store_uint(query_id, 64)
            .store_uint(gpkx, 256)
            .store_uint(gpky, 256)
            .store_ref(in_msg_body~load_ref())
            .end_cell();
        return send_raw_message(msg,80);
    }
    if(op & 0xFF000000 == OP_COMMON) {
        if(op == OP_COMMON_SetHalt) {
            int _halt = in_msg_body~load_uint(2);
            (int workchain, int hash) = parse_std_addr(sender_address);
            cb_executed(sender_address, query_id);
            save_data(cross_owner, _halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }
        ;; if(op == OP_COMMON_Initialize) { ;; TODO need not?
        ;;     int _init = in_msg_body~load_uint(2);
        ;;     save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
        ;;     return ();
        ;; }
        if(op == OP_COMMON_TransferOwner) {
            slice _cross_owner = in_msg_body~load_msg_addr();
            cb_executed(sender_address, query_id);
            save_data(_cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }
    }

    if ((op & 0xFF000000 == OP_CROSS) | (op == OP_TRANSFER_NOTIFICATION) | (op == OP_EXCESSES )) {
        ;; var _extend = cross_recv_internal(op, extend, msg_value, in_msg_full, in_msg_body);
        ;; save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, _extend);
        ~strdump("Entering op_cross...");

        var _oracle = cross_recv_internal(op, query_id, token_manager,msg_value, in_msg_full, in_msg_body,oracle,ca_fee);
        ;;cb_executed(sender_address,query_id); ;;todo check it carefully.
        save_data(cross_owner, halt, init, ca_fee, _oracle, token_manager, extend);
        return ();
    }

    if (op & 0xFF000000 == OP_FEE ) {
        var _ca_fee = fee_recv_internal(op, ca_fee, msg_value, in_msg_full, in_msg_body);
        cb_executed(sender_address, query_id);
        save_data(cross_owner, halt, init, _ca_fee, oracle, token_manager, extend);
        return ();
    }

    if (op & 0xFF000000 == OP_ORACLE) {
        var _oracle = oracle_recv_internal(op, oracle, msg_value, in_msg_full, in_msg_body);
        cb_executed(sender_address, query_id);
        save_data(cross_owner, halt, init, ca_fee, _oracle, token_manager, extend);
        return ();
    }

    if (op & 0xFF000000 == OP_TOKENPAIR) {
        var _token_manager = tm_recv_internal(op, token_manager, msg_value, in_msg_full, in_msg_body);
        cb_executed(sender_address, query_id);
        save_data(cross_owner, halt, init, ca_fee, oracle, _token_manager, extend);
        return ();
    }

    ;; if (op & 0xFF000000 == OP_EXTEND) {
    ;;     var _extend = ext_recv_internal(op, extend, msg_value, in_msg_full, in_msg_body);
    ;;     cb_executed(sender_address, query_id);
    ;;     save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, _extend);
    ;;     return ();
    ;; }

    if (op == OP_UPGRADE_Code) {
        var new_code = in_msg_body~load_ref();
        set_code(new_code);
        return cb_executed(sender_address, query_id);
    }

    throw(error::recv_unknown_opcode); ;; if the message contains an op that is not known to this contract, we throw
}

(slice, int, int) get_cross_config() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return (cross_owner, halt, init);
}

;; getter for oracle
(slice) get_oracle_admin() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_OracleAdmin(oracle);
}
(slice, slice) get_fee_config() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return fee_get_config(ca_fee);
}

(int, int, int,int,int) get_smgConfig(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_smg(oracle, id, 0);
}

(int, int) get_chain_fee(int _src_chain_id, int _dst_chain_id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return fee_get_chain_fee(ca_fee,_src_chain_id,_dst_chain_id);
}
(int) get_tokenpair_fee(int tokenpairID) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return fee_get_tokenpair_fee(ca_fee,tokenpairID);
}
(int) get_first_smg_id() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_first_smg_id(oracle,0);
}
(int) get_next_smg_id(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_next_smg_id(oracle, id,0);
}

(int) get_first_smg_id_Commited() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_first_smg_id(oracle, 1);    
}
(int) get_next_smg_id_Commited(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_next_smg_id(oracle, id, 1);
}
;; getter for tokenManager
(int, slice, int, slice,slice) get_token_pair(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_token_pair(token_manager, id);
}
(int) get_first_tokenpair_id() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_first_tokenpair_id(token_manager);
}
(int) get_next_tokenpair_id(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_next_tokenpair_id(token_manager, id);
}

;; getter for extend
(slice) get_first_crossAdmin() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return fee_get_first_crossAdmin(ca_fee);
}
(slice) get_next_crossAdmin(slice adminAddr) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return fee_get_next_crossAdmin(ca_fee, adminAddr);
}

;; for test.
;; (int) get_updated_int() method_id {
;;     (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
;;     return ext_get_updated_int(extend);
;; }

(slice) version() method_id {
    return "0.1";
}