#include "imports/std/stdlib.fc";
#include "imports/common/opcode.fc";
#include "imports/util/slice.fc";
#include "imports/crypto/secp256k1.fc";
#include "imports/common/wkchain.fc";
#include "imports/common/errcode.fc";
#include "tokenManager.fc";
#include "fee.fc";
#include "extend.fc";
#include "oracle.fc";

;; load_data populates storage variables using stored data
(slice, int, int, cell, cell, cell, cell) load_data() impure {
    var ds = get_data().begin_parse();
    slice cross_owner = ds~load_msg_addr();
    (int halt, int init) = (ds~load_uint(2), ds~load_uint(2));
    (cell ca_fee, cell oracle, cell token_manager, cell extend) = (ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref());
    ds.end_parse();
    return (cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
}

;; save_data stores storage variables as a cell into persistent storage
() save_data(slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) impure {
    set_data(
        begin_cell()
            .store_slice(cross_owner)
            .store_uint(halt, 2)
            .store_uint(init, 2)
            .store_ref(ca_fee)
            .store_ref(oracle)
            .store_ref(token_manager)
            .store_ref(extend)
            .end_cell()
    );
}

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee

    ;;todo should check the rights

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    if(op & 0xFF000000 == OP_COMMON) {
        if(op == OP_COMMON_SetHalt) {
            int _halt = in_msg_body~load_uint(2);
            save_data(cross_owner, _halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }
        if(op == OP_COMMON_Initialize) {
            int _init = in_msg_body~load_uint(2);
            save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }
        if(op == OP_COMMON_TransferOwner) {
            slice _cross_owner = in_msg_body~load_msg_addr();
            ~strdump(_cross_owner);
            save_data(_cross_owner, halt, init, ca_fee, oracle, token_manager, extend);
            return ();
        }        
    }
    if (op & 0xFF000000 == OP_FEE) {
        var _ca_fee = fee_recv_internal(op, ca_fee, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, _ca_fee, oracle, token_manager, extend);
        return ();
    }
    if (op & 0xFF000000 == OP_ORACLE) {
        var _oracle = oracle_recv_internal(op, oracle, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, ca_fee, _oracle, token_manager, extend);
        return ();
    }    
    if (op & 0xFF000000 == OP_TOKENPAIR) {
        var _token_manager = tm_recv_internal(op, token_manager, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, ca_fee, oracle, _token_manager, extend);
        return ();
    }
    if (op & 0xFF000000 == OP_EXTEND) {
        var _extend = ext_recv_internal(op, extend, msg_value, in_msg_full, in_msg_body);
        save_data(cross_owner, halt, init, ca_fee, oracle, token_manager, _extend);
        return ();
    } 
    if (op == OP_UPGRADE) {
        var new_code = in_msg_body~load_ref();
        set_code(new_code);
        return ();
    }
    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

(slice, int, int) get_cross_config() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return (cross_owner, halt, init);
}


;; getter for oracle
(int, int, int) get_smgConfig(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_smg(oracle, id);
}
(int) get_first_smg_id() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_first_smg_id(oracle);    
}
(int) get_next_smg_id(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return oracle_get_next_smg_id(oracle, id);
}

;; getter for tokenManager
(int, slice, int, slice) get_token_pair(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_token_pair(token_manager, id);
}
(int) get_first_tokenpair_id() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_first_tokenpair_id(token_manager);    
}
(int) get_next_tokenpair_id(int id) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return tm_get_next_tokenpair_id(token_manager, id);
}

;; getter for extend
(slice) get_first_crossAdmin() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return ext_get_first_crossAdmin(extend);
}
(slice) get_next_crossAdmin(slice adminAddr) method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return ext_get_next_crossAdmin(extend, adminAddr);
}

;; for test. 
(int) get_updated_int() method_id {
    (slice cross_owner, int halt, int init, cell ca_fee, cell oracle, cell token_manager, cell extend) = load_data();
    return ext_get_updated_int(extend);
}

(slice) version() method_id {
    return "0.1";
}