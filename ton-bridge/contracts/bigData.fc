#include "./imports/std/stdlib.fc";
#include "./jetton/messages.func";
#include "imports/util/slice.fc";

(cell) load_data() inline {
    var ds = get_data().begin_parse();
    var dic = ds~load_dict();
    ds.end_parse();
    return dic;
}

() save_data(cell taskDict) impure inline {
    set_data(begin_cell()
        .store_dict(taskDict)
        .end_cell());
}


() refund_executed(refundAddress) impure {
    var msg = begin_cell()
        .store_msg_flag(0x18)
        .store_slice(refundAddress)
        .store_coins(0)
        .store_msgbody_prefix_slice()
        .store_uint(0, 64)
        .end_cell();
    send_raw_message(msg, CARRY_REMAINING_BALANCE);
    return ();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    slice dest_address = cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee

    (cell dict) = load_data();

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case


    if (op == 0x12345678) {
        var (tslice, found?) = dict.udict_get?(256, query_id);
        if (found?) {
            throw(4000);
        } else {
            int count = in_msg_body~load_uint(64);
            int start = query_id;
            while (count) {
                slice slice_value = int_to_slice(start, 256);
                dict~udict_set(256, start, slice_value);
                count -= 1;
                start += 1;
            }
            save_data(dict);
        }
        refund_executed(sender_address);
    }

    return ();
}

(int) get_by_id(int id) method_id {
    (cell dict) = load_data();
    (slice svalue, int success) = dict.udict_get?(256, id);
    if (success) {
        return slice_to_int(svalue, 256);
    } else {
        return 0;
    }
}
